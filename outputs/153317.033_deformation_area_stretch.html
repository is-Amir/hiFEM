<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={334:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},819:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return cI},load:function(){return lI}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return D},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return De},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return Ee},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],E=r[2],D=Math.hypot(R,M,E);return D<a?null:(R*=D=1/D,M*=D,E*=D,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,P=M*E*s-R*o,O=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),D(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,E=(1-(p+v))*C,D=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=D,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+E*I+L*w),e[14]=n[2]+w-(R*A+D*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],E=t[12],D=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-D)<=a*Math.max(1,Math.abs(h),Math.abs(D))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function De(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=Ee,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol("void"),$e={};function qe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty("log")?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st("_"===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et("instance deleted - cannot call any method"),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&tt('Setter of type "object" with a single "param" field is not supported');const r=`_on${lt(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function Ct(e){if("object"==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et("instance deleted - cannot call any method"):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?et("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol("Event abort");function Et(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et("instance deleted - cannot call any method"),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Dt(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA("vtkObject")}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt="__root__";function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,["proxyId","proxyGroup","proxyName"]),At(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Et,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Dt,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt,objectSetterMap:xt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Et,newInstance:Dt,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>{if(!t._parent)return null;return t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null)},e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=t=>{if(t&&t.length)for(let n=0;n<t.length;++n){const r=t[n];e.addMissingNode(r)}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,"event"),t._renderableChildMap=new Map,jt.get(e,t,["visited"]),jt.setGet(e,t,["_parent","renderable","myFactory"]),jt.getArray(e,t,["children"]),jt.moveToProtected(e,t,["parent"]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,"vtkViewNode"),extend:Yt,PASS_TYPES:["Build","Render"]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,"vtkViewNodeFactory"),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,"vtkOpenGLViewNodeFactory"),extend:sn};function cn(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,["context","keyMatrixTime"]),cn(e,t)}));rn("vtkCamera",dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,["shaderCache"]),At(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),fn(e,t)}),"vtkOpenGLRenderer");function hn(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkRenderer",mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn("vtkActor",yn);const bn={context:null,activeTextures:null};const xn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,["context"]),bt(e,t,["activeTextures"]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function En(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Dn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn("vtkActor2D",xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn="\\s*([+-]?\\d+)\\s*",Jn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",er="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\(${Qn},${Qn},${Qn}\\)$`),rr=new RegExp(`^rgb\\(${er},${er},${er}\\)$`),or=new RegExp(`^rgba\\(${Qn},${Qn},${Qn},${Jn}\\)$`),ar=new RegExp(`^rgba\\(${er},${er},${er},${Jn}\\)$`),ir=new RegExp(`^hsl\\(${Jn},${er},${er}\\)$`),sr=new RegExp(`^hsla\\(${Jn},${er},${er},${Jn}\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):"transparent"===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?"rgb(":"rgba("}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?")":`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?"0":"")+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?"hsl(":"hsla("}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?")":`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Er=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Dr(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Dr((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Dr((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Fr=new RegExp(_r.source,"g");function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||"boolean"===r?Rr(t):("number"===r?Br:"string"===r?(n=dr(t))?(t=n,Er):kr:t instanceof dr?Er:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error("invalid format: "+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var ao={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;"n"===y?(m=!0,y="g"):ao[y]||(void 0===h&&(h=12),v=!0,y="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var T="$"===p?o:"#"===p&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",b="$"===p?a:/[%p]/.test(y)?l:"",x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if("c"===y)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===y?po[8+Qr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Eo,ceil:Do,min:Vo,max:Lo}=Math;const Bo=Ao("ceilLog2"),No=Ao("factorial");function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao("gaussian");function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Ea(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Da=Ao("GetScalarTypeFittingRange"),Va=Ao("GetAdjustedScalarRange");const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Eo,ceil:Do,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co("Insufficient number of samples. Underdetermined."),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Ea,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Da,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";return`${t}${e.map(Ga).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(", ")})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};function Wa(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{jt.vtkErrorMacro("not implemented")}}const Ha={};function ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ha,n),jt.obj(e,t),jt.setGet(e,t,["transform"]),Wa(e,t)}var Ka={newInstance:jt.newInstance(ja,"vtkImplicitFunction"),extend:ja};const $a=1e-6,qa="coincide",Xa="disjoint";function Ya(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function Za(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function Qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Ja(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function ei(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*$a:s*$a,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function ti(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<$a){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=qa:o.error=Xa,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const ni={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ya,projectPoint:Za,projectVector:Qa,generalizedProjectPoint:Ja,intersectWithLine:ei,intersectWithPlane:ti,DISJOINT:Xa,COINCIDE:qa};function ri(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ya(e,t.origin,t.normal),e.projectPoint=(e,n)=>{Za(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>Qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Ja(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>ei(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>ti(e,n,t.origin,t.normal)}const oi={normal:[0,0,1],origin:[0,0,0]};function ai(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oi,n),Ka.extend(e,t,n),jt.setGetArray(e,t,["normal","origin"],3),ri(e,t)}var ii={newInstance:jt.newInstance(ai,"vtkPlane"),extend:ai,...ni};const si=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function li(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ci(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ui(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function di(e){return ui(e,si)}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function fi(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)pi(e,...t[n]);else for(let n=0;n<t.length;n+=3)pi(e,...t.slice(n,n+3));return e}function gi(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function mi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function hi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function vi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function yi(e,t,n,r){return!!ci(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function Ti(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function bi(e,t){return e[2*t+1]-e[2*t]}function xi(e){return[bi(e,0),bi(e,1),bi(e,2)]}function Ci(e){return e.slice(0,2)}function Si(e){return e.slice(2,4)}function Ai(e){return e.slice(4,6)}function Ii(e){const t=xi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function wi(e){if(ci(e)){const t=xi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Pi(e){return[e[0],e[2],e[4]]}function Oi(e){return[e[1],e[3],e[5]]}function Ri(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Mi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Ei(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Di(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Mi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return di(n),fi(n,r)}function Vi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Li(e,t,n,r){const o=[].concat(si),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Bi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ni(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ii.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function _i(e,t){if(!ci(e)||!ci(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Fi(e,t){if(!ci(e)||!ci(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function ki(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Gi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ii.evaluate(n,t,l)}let i=2;for(;i--&&!(Ri(o[r[i][0]],o[r[i][4]])&&Ri(o[r[i][1]],o[r[i][5]])&&Ri(o[r[i][2]],o[r[i][6]])&&Ri(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ui{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(si))}getBounds(){return this.bounds}equals(e){return li(this.bounds,e)}isValid(){return ci(this.bounds)}setBounds(e){return ui(this.bounds,e)}reset(){return di(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return pi(this.bounds,...t)}addPoints(e){return fi(this.bounds,e)}addBounds(e,t,n,r,o,a){return gi(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return mi(this.bounds,e,t,n)}setMaxPoint(e,t,n){return hi(this.bounds,e,t,n)}inflate(e){return vi(this.bounds,e)}scale(e,t,n){return yi(this.bounds,e,t,n)}getCenter(){return Ti(this.bounds)}getLength(e){return bi(this.bounds,e)}getLengths(){return xi(this.bounds)}getMaxLength(){return Ii(this.bounds)}getDiagonalLength(){return wi(this.bounds)}getMinPoint(){return Pi(this.bounds)}getMaxPoint(){return Oi(this.bounds)}getXRange(){return Ci(this.bounds)}getYRange(){return Si(this.bounds)}getZRange(){return Ai(this.bounds)}getCorners(e){return Mi(this.bounds,e)}computeCornerPoints(e,t){return Ei(this.bounds,e,t)}computeLocalBounds(e,t,n){return Li(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Di(this.bounds,e,t)}computeScale3(e){return Vi(this.bounds,e)}cutWithPlane(e,t){return Gi(this.bounds,e,t)}intersectBox(e,t,n,r){return Bi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ni(this.bounds,e,t)}intersect(e){return _i(this.bounds,e)}intersects(e){return Fi(this.bounds,e)}containsPoint(e,t,n){return ki(this.bounds,e,t,n)}contains(e){return Fi(this.bounds,e)}}var zi,Wi={newInstance:function(e){const t=e&&e.bounds;return new Ui(t)},equals:li,isValid:ci,setBounds:ui,reset:di,addPoint:pi,addPoints:fi,addBounds:gi,setMinPoint:mi,setMaxPoint:hi,inflate:vi,scale:yi,scaleAboutCenter:function(e,t,n,r){if(!ci(e))return!1;const o=Ti(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],yi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:Ti,getLength:bi,getLengths:xi,getMaxLength:Ii,getDiagonalLength:wi,getMinPoint:Pi,getMaxPoint:Oi,getXRange:Ci,getYRange:Si,getZRange:Ai,getCorners:Mi,computeCornerPoints:Ei,computeLocalBounds:Li,transformBounds:Di,computeScale3:Vi,cutWithPlane:Gi,intersectBox:Bi,intersectPlane:Ni,intersect:_i,intersects:Fi,containsPoint:ki,contains:function(e,t){return!!Fi(e,t)&&!!ki(e,...Pi(t))&&!!ki(e,...Oi(t))},INIT_BOUNDS:si};function Hi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function ji(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Ki(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function $i(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}zi=new i(4),i!=Float32Array&&(zi[0]=0,zi[1]=0,zi[2]=0,zi[3]=0);var qi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),ji(),ji(),ie();var Xi={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Yi}=Xi;function Zi(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function Qi(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Zi("pick"),e.hasKey=Zi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Yi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Yi.DISPLAY)}const Ji={allocatedRenderTime:10,coordinateSystem:Yi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),jt.obj(e,t),jt.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),jt.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),jt.moveToProtected(e,t,["parentProp"]),Qi(e,t)}var ts={newInstance:jt.newInstance(es,"vtkProp"),extend:es,...Xi};function ns(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=ji();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return N(e,t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=ji();Ki(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=k(new Float64Array(16),n);T(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>Wi.getCenter(t.bounds),e.getLength=()=>Wi.getLength(t.bounds),e.getXRange=()=>Wi.getXRange(t.bounds),e.getYRange=()=>Wi.getYRange(t.bounds),e.getZRange=()=>Wi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const rs={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function os(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rs,n),ts.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,["bounds","isIdentity"]),jt.getArray(e,t,["orientation"]),jt.setGetArray(e,t,["origin","position","scale"],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,ns(e,t)}var as={newInstance:jt.newInstance(os,"vtkProp3D"),extend:os};const is={FLAT:0,GOURAUD:1,PHONG:2},ss={POINTS:0,WIREFRAME:1,SURFACE:2};var ls={Shading:is,Representation:ss,Interpolation:is};const{Representation:cs,Interpolation:us}=ls;function ds(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ps(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ds("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ds("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(us.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(us.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(us.PHONG),e.getInterpolationAsString=()=>jt.enumToString(us,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(cs.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(cs.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(cs.POINTS),e.getRepresentationAsString=()=>jt.enumToString(cs,t.representation)}const fs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:us.GOURAUD,representation:cs.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fs,n),jt.obj(e,t),jt.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture"]),jt.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),ps(e,t)}var ms={newInstance:jt.newInstance(gs,"vtkProperty"),extend:gs,...ls};const{vtkDebugMacro:hs}=jt;function vs(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ms.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){hs("Recomputing bounds..."),t.mapperBounds=n.concat();const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const ys={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function Ts(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),vs(e,t)}var bs={newInstance:jt.newInstance(Ts,"vtkActor"),extend:Ts};const xs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},Cs={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var Ss={DefaultDataType:Cs.FLOAT,DataTypeByteSize:xs,VtkDataTypes:Cs};const{vtkErrorMacro:As}=Kt,{DefaultDataType:Is}=Ss,ws=1e-6;function Ps(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function Os(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ps(r,0,1)}return Ps(e,t<0?0:t,n)}function Rs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function Ms(e){return Object.prototype.toString.call(e).slice(8,-1)}const Es={computeRange:Os,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ps,getDataType:Ms,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Ds(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=Os(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ws;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Bs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=Ms(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||As("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Vs={name:"",numberOfComponents:1,dataType:Is,rangeTuple:[0,0]};function Ls(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Vs,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=Ms(t.values)),yt(e,t),St(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");Ds(e,t)}const Bs=Dt(Ls,"vtkDataArray");var Ns={newInstance:Bs,extend:Ls,...Es,...Ss};function _s(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Fs={clippingPlanes:[]};var ks=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fs,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),_s(e,t)};function Gs(e,t){e.getBounds=()=>(jt.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=Wi.isValid(n)?Wi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Wi.getDiagonalLength(t)}}const Us=e=>({bounds:[...Wi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var zs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Us(n)),ks(e,t,n),jt.setGet(e,t,["viewSpecificProperties"]),Gs(e,t)};const{vtkErrorMacro:Ws,vtkWarningMacro:Hs}=jt;function js(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Ws("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ns.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Hs("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Ws("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ns.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const Ks={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function $s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ks,n),jt.obj(e,t),js(e,t)}var qs={newInstance:jt.newInstance($s,"vtkFieldData"),extend:$s};const Xs={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ys={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Xs,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Zs,AttributeCopyOperations:Qs}=Ys,{vtkWarningMacro:Js}=jt;function el(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Zs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Qs).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Qs[e]]=Object.keys(Zs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Zs[t]]=!0,e)),[])})),t.copyAttributeFlags[Qs.COPYTUPLE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.INTERPOLATE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.COPYTUPLE][Zs.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ns.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const tl={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tl,n),qs.extend(e,t,n),jt.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),el(e,t)}var rl={newInstance:jt.newInstance(nl,"vtkDataSetAttributes"),extend:nl,...Ys};const ol=["pointData","cellData","fieldData"];function al(e,t){t.classHierarchy.push("vtkDataSet"),ol.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=rl.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),ol.forEach((n=>{t[n]=rl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const il={};function sl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,il,n),jt.obj(e,t),jt.setGet(e,t,ol),al(e,t)}var ll={newInstance:jt.newInstance(sl,"vtkDataSet"),extend:sl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const cl={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ul={StructuredType:cl};const{StructuredType:dl}=ul;var pl={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?dl.EMPTY:3===t?dl.XYZ_GRID:2===t?e[0]===e[1]?dl.YZ_PLANE:e[2]===e[3]?dl.XZ_PLANE:dl.XY_PLANE:1===t?e[0]<e[1]?dl.X_LINE:e[2]<e[3]?dl.Y_LINE:dl.Z_LINE:dl.SINGLE_POINT},...ul};const{vtkErrorMacro:fl}=jt;function gl(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return fl("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=pl.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)fl("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void fl("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return fl("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case cl.EMPTY:return null;case cl.SINGLE_POINT:break;case cl.X_LINE:o[0]=n;break;case cl.Y_LINE:o[1]=n;break;case cl.Z_LINE:o[2]=n;break;case cl.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case cl.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case cl.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case cl.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:fl("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Wi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Wi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Wi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Wi.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Ea(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ea(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return fl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return fl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const ml={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:cl.EMPTY};function hl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ml,n),ll.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,["indexToWorld","worldToIndex"]),jt.setGetArray(e,t,["origin","spacing"],3),jt.setGetArray(e,t,["direction"],9),jt.getArray(e,t,["extent"],6),gl(e,t)}var vl={newInstance:jt.newInstance(hl,"vtkImageData"),extend:hl};const yl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Tl={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:yl},bl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:xl,VectorMode:Cl}=Tl,{VtkDataTypes:Sl}=Ns,{ColorMode:Al}=bl,{vtkErrorMacro:Il}=jt;function wl(e){return e}function Pl(e){return Math.floor(255*e+.5)}function Ol(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Cl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Cl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Cl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)Il("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===Al.DEFAULT&&(t.getDataType()===Sl.UNSIGNED_CHAR||t.getDataType()===Sl.UNSIGNED_CHAR_CLAMPED)||n===Al.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Sl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ns.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,xl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,xl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Cl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Cl.MAGNITUDE||1!==c&&1!==s||(i=Cl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Cl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Cl.RGBCOLORS:break;case Cl.MAGNITUDE:default:{const o=Ns.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Pl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Sl.UNSIGNED_CHAR)return n;const i=Ns.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Sl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=wl;switch(n.getDataType()!==Sl.FLOAT&&n.getDataType()!==Sl.DOUBLE||(s=Pl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return Il("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==Al.DEFAULT||n.getDataType()!==Sl.UNSIGNED_CHAR)&&r!==Al.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Rl={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Cl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function Ml(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rl,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),jt.setArray(e,t,["mappingRange"],2),jt.getArray(e,t,["mappingRange"]),Ol(e,t)}var El={newInstance:jt.newInstance(Ml,"vtkScalarsToColors"),extend:Ml,...Tl};const{vtkErrorMacro:Dl}=jt;function Vl(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Dl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==Cs.UNSIGNED_CHAR)return Dl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Bl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ll,n),El.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,["buildTime"]),jt.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),jt.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),Vl(e,t)}var Nl={newInstance:jt.newInstance(Bl,"vtkLookupTable"),extend:Bl};const _l={Off:0,PolygonOffset:1};let Fl=_l.PolygonOffset,kl=_l.Off;const Gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function Ul(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=kl===e;return kl=e,t}var zl={Resolve:_l,getResolveCoincidentTopologyAsString:function(){return Gl[kl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Fl},getResolveCoincidentTopology:function(){return kl},setResolveCoincidentTopology:Ul,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=Fl===e;return Fl=e,t},setResolveCoincidentTopologyToDefault:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToOff:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return Ul(_l.PolygonOffset)}};function Wl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=jt.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Hl=["Polygon","Line","Point"],jl={modified:()=>{}};Wl(jl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Hl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Kl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(zl).forEach((t=>{e[t]=zl[t]})),Object.keys(jl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=jl[t]})),Wl(e,t.topologyOffset,Hl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=jl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:jl,otherStaticMethods:zl,CATEGORIES:Hl,Resolve:_l};const $l={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var ql={PassTypes:$l};const{FieldAssociations:Xl}=ll,{staticOffsetAPI:Yl,otherStaticMethods:Zl}=Kl,{ColorMode:Ql,ScalarMode:Jl,GetArray:ec}=bl,{VectorMode:tc}=Tl,{VtkDataTypes:nc}=Ns;function rc(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function oc(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function ac(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const ic=new WeakMap;function sc(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(Ql,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(Jl,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Jl.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Jl.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Jl.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Jl.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_FIELD_DATA){const t=e.getFieldData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale();i&&Nl.getLogRange(a,a);const s=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,u=n**3-3,d=4094,p=2,f=r?u:d;t.numberOfColorsInRange=Math.min(Math.max(e,p),f);const g=t.numberOfColorsInRange+3,m=t.numberOfColorsInRange+2,h=r?[Math.min(Math.ceil(g/n**0),n),Math.min(Math.ceil(g/n**1),n),Math.min(Math.ceil(g/n**2),n)]:[m,2,1],v=h[0]*h[1]*h[2],y=new Float64Array(v);y.fill(NaN);const T=t.numberOfColorsInRange,b=T+2,x=[0,0,0],C=a[0],S=a[1]-a[0];for(let e=0;e<b;++e){const t=C+S*(e-1)/(T-1);y[(c=h,(l=x)[0]+c[0]*(l[1]+c[1]*l[2]))]=i?10**t:t,oc(x,h)}const A=Ns.newInstance({numberOfComponents:1,values:y}),I=t.lookupTable.mapScalars(A,t.colorMode,0);t.colorTextureMap=vl.newInstance(),t.colorTextureMap.setDimensions(h),t.colorTextureMap.getPointData().setScalars(I),t.lookupTable.setAlpha(s)}var l,c;const u=t.lookupTable.getVectorMode()===tc.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=ic.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(r-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(r+1)/(p-d),v=e.getData(),y=e.getNumberOfTuples(),T=e.getNumberOfComponents(),b=t<0||t>=T,x=o[2]<=1?2:3,C=Ns.newInstance({numberOfComponents:x,values:new Float32Array(y*x)}),S=C.getData(),A=[0,0,0];ac(A,r+2,o);let I=0,w=0;const P=[.5,.5,.5];for(let e=0;e<y;++e){let e;if(b){let t=0;for(let e=0;e<T;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(I+=T,a&&(e=Nl.applyLogScale(e,n,n)),_a(e))P[0]=A[0],P[1]=A[1],P[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>r&&(t=r+1),ac(P,t,o)}else{P[1]=.49;const t=(e-f)*g;P[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=P[e]}return ic.set(e,{stringHash:l,textureCoordinates:C}),C}(n,u,a,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),i,r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===Ql.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===Ql.DEFAULT&&e.getDataType()===nc.UNSIGNED_CHAR||t.colorMode===Ql.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=rc("AcquireInvertibleLookupTable"),e.valueToColor=rc("ValueToColor"),e.colorToValue=rc("ColorToValue"),e.useInvertibleColorFor=rc("UseInvertibleColorFor"),e.clearInvertibleColor=rc("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer($l.ID_LOW24),o=e.getRawPixelBuffer($l.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Xl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Xl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===$l.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer($l.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===$l.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer($l.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const lc={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lc,n),zs(e,t,n),jt.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),jt.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),Kl.implementCoincidentTopologyMethods(e,t),sc(e,t)}var uc={newInstance:jt.newInstance(cc,"vtkMapper"),extend:cc,...Yl,...Zl,...bl};function dc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function pc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const fc={extractCellSizes:dc,getNumberOfCells:pc};function gc(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=pc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=dc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function mc(e){return{empty:!0,numberOfComponents:1,dataType:Cs.UNSIGNED_INT,...e}}function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ns.extend(e,t,mc(n)),gc(e,t)}var vc={newInstance:jt.newInstance(hc,"vtkCellArray"),extend:hc,...fc};const{vtkErrorMacro:yc}=jt,Tc=[1,-1,1,-1,1,-1];function bc(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return yc(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),Tc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const xc={empty:!0,numberOfComponents:3,dataType:Cs.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),Ns.extend(e,t,n),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,"vtkPoints"),extend:Cc};function Ac(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}const Ic={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ic,n),jt.obj(e,t),t.points||(t.points=Sc.newInstance()),jt.get(e,t,["points","pointsIds"]),Ac(e,t)}var Pc={newInstance:jt.newInstance(wc,"vtkCell"),extend:wc};function Oc(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Pc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Pc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const Rc={array:null,maxId:0,extend:0};function Mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rc,n),jt.obj(e,t),Oc(e,t)}var Ec={newInstance:jt.newInstance(Mc,"vtkCellLinks"),extend:Mc};const Dc=0,Vc=1,Lc=2,Bc=3,Nc=4,_c=5,Fc=6,kc=7,Gc=9,Uc=21,zc=41,Wc=42,Hc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],jc={getClassNameFromTypeId:function(e){return e<Hc.length?Hc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return Hc.findIndex(e)},isLinear:function(e){return e<Uc||e===zc||e===Wc},hasSubCells:function(e){return e===Fc||e===Nc||e===Lc}};function Kc(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Dc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const $c={size:0,maxId:-1,extend:1e3};function qc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$c,n),jt.obj(e,t),jt.get(e,t,["size","maxId","extend"]),jt.getArray(e,t,["typeArray","locationArray"]),Kc(e,t)}var Xc={newInstance:jt.newInstance(qc,"vtkCellTypes"),extend:qc,...jc},Yc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Zc}=Yc;function Qc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function Jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Qc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Zc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Zc.YES_INTERSECTION:Zc.NO_INTERSECTION}const eu={distanceToLine:Qc,intersection:Jc};function tu(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=Jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Zc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Qc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Qc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Qc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Qc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const nu={orientations:null};function ru(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nu,n),Pc.extend(e,t,n),jt.setGet(e,t,["orientations"]),tu(e,t)}var ou={newInstance:jt.newInstance(ru,"vtkLine"),extend:ru,...eu,...Yc};function au(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=Sc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=Sc.newInstance(),t.points.shallowCopy(e.getPoints())}}const iu={};function su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),ll.extend(e,t,n),jt.setGet(e,t,["points"]),au(e,t)}var lu={newInstance:jt.newInstance(su,"vtkPointSet"),extend:su};function cu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function uu(e,t,n,r){cu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const du={computeNormalDirection:cu,computeNormal:uu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];uu(e,t,n,d),uu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ii.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ii.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[E],P[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function pu(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(uu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ii.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=ou.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),cu(l,c,u,d),ii.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=ou.distanceToLine(e,c,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=ou.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=ou.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=ou.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const fu={};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Pc.extend(e,t,n),pu(e,t)}var mu={newInstance:jt.newInstance(gu,"vtkTriangle"),extend:gu,...du};const hu=["verts","lines","polys","strips"],{vtkWarningMacro:vu}=jt,yu={[Bc]:ou,[Nc]:ou,[_c]:mu};function Tu(e,t){t.classHierarchy.push("vtkPolyData"),hu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=vc.newInstance()})),e.getNumberOfCells=()=>hu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),hu.forEach((n=>{t[n]=vc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?Lc:Vc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Nc:Bc,1===t&&vu("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=_c;break;case 4:l[n]=Gc;break;default:l[n]=kc}t<3&&vu("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Fc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Xc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Vc:case Lc:o=t.verts;break;case Bc:case Nc:o=t.lines;break;case _c:case Gc:case kc:o=t.polys;break;case Fc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||yu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const bu={};function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bu,n),lu.extend(e,t,n),jt.get(e,t,["cells","links"]),jt.setGet(e,t,["verts","lines","polys","strips"]),Tu(e,t)}var Cu={newInstance:jt.newInstance(xu,"vtkPolyData"),extend:xu};function Su(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement("canvas");e.width=t.image.width,e.height=t.image.height;const n=e.getContext("2d");return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const Au={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Au,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,["canvas","image","jsImageData","imageLoaded","resizable"]),jt.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),Su(e,t)}const wu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Pu={newInstance:jt.newInstance(Iu,"vtkTexture"),extend:Iu,...wu};const Ou=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Ru=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Mu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Eu=[0,1,0,1,0,1,0,1,2,2,2,2],Du=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Vu=new Float64Array(3),Lu=new Float64Array(3),Bu=new Float64Array(3),Nu=new Float64Array(3),_u=new Float64Array(3),Fu=new Float64Array(3),ku=new Float64Array(16);function Gu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Uu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=go().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}function zu(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],Vn(Bu,Vu,r),Bu[0]+=.1,Vn(Lu,Bu,o),Pn(_u,Lu,Vu),Bu[0]-=.1,Bu[1]+=.1,Vn(Lu,Bu,o),Pn(Fu,Lu,Vu);for(let e=0;e<3;e++)_u[e]/=.05*u[0],Fu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],a[0]<-.5?On(Bu,_u,a[0]*i-l.width):a[0]>.5?On(Bu,_u,a[0]*i):On(Bu,_u,a[0]*i-l.width/2),wn(Vu,Vu,Bu),On(Bu,Fu,a[1]*i-l.height/2),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Bu,_u,l.width),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Bu,Fu,l.height),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Bu,_u,l.width),Pn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(ku,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Vu[0]=f[3*u],Vu[1]=f[3*u+1],Vu[2]=f[3*u+2],Vn(Bu,Vu,n),Vu[0]=f[3*u+3],Vu[1]=f[3*u+4],Vu[2]=f[3*u+5],Vn(Nu,Vu,n),Pn(Bu,Bu,Nu);const r=[Bu[0],Bu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Wu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,["renderable"]),jt.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],zu(e,t)}),"vtkCubeAxesActorHelper");function Hu(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Wi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Vu[s]=t.dataBounds[a]-.1*r*Ou[a][s],Vu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Vu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Bu,Vu,e),Vu[s]=t.dataBounds[a],Vn(Nu,Vu,e),Pn(Bu,Nu,Bu),Mn(Bu,Bu),i=Bu[2]>o,t.camera.getParallelProjection()||(Mn(Nu,Nu),i=En(Nu,Bu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Du[t][0]].length+2*r[Du[t][1]].length,a+=r[Du[t][0]].length+r[Du[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Mu[e][0],l[3*u+2]=Mu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Du[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Du[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Eu[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Ru[a][e];if(1===n[d]){const e=Eu[d],n=3*Mu[d][0],p=3*Mu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Du[a][0]]=.5*(t.dataBounds[2*Du[a][0]]+t.dataBounds[2*Du[a][0]+1]),s[3*l+Du[a][1]]=.5*(t.dataBounds[2*Du[a][1]]+t.dataBounds[2*Du[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Ru[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Gu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Gu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Gu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Wi.setBounds(t.bounds,t.gridActor.getBounds()),Wi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function ju(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Wi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:Uu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}function Ku(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,ju(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=uc.newInstance(),t.polyData=Cu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=bs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Cu.newInstance(),jt.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),jt.setGetArray(e,t,["dataBounds"],6),jt.setGetArray(e,t,["axisLabels"],3),jt.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),Hu(e,t)}var $u={newInstance:jt.newInstance(Ku,"vtkCubeAxesActor"),extend:Ku,newCubeAxesActorHelper:Wu,defaultGenerateTicks:Uu};function qu(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Xu={};const Yu=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=$u.newCubeAxesActorHelper(),qu(e,t)}),"vtkOpenGLCubeAxesActor");rn("vtkCubeAxesActor",Yu);const Zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Qu={ObjectType:Zu};const{ObjectType:Ju}=Qu;function ed(e,t){function n(e){switch(e){case Ju.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Ju.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case Ju.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const td={objectType:Ju.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function nd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,td,n),jt.obj(e,t),jt.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),ed(e,t)}var rd={newInstance:jt.newInstance(nd),extend:nd,...Qu};const{vtkErrorMacro:od}=jt;function ad(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(Zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=rd.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===ss.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===ss.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,E=0,D=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];E+=n*n;const r=.5*(t[1]+t[0]);D+=r*r}const V=E>0&&(Math.abs(D)/E>1e6||Math.abs(Math.log10(E))>3||0===E&&D>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,T++)C(A[e],A,e+1,T+a.cellOffset);return t.elementCount=w,e.upload(O,Zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,Zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,ji(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):od("Wrong type for coordScale, expected vec3 or null"):od("Wrong type for coordShift, expected vec3 or null")}}const id={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,id,n),rd.extend(e,t,n),jt.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),jt.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),ad(e,t)}var ld={newInstance:jt.newInstance(sd),extend:sd};const{vtkErrorMacro:cd}=jt;function ud(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return cd(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const dd={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),jt.obj(e,t),jt.setGet(e,t,["shaderType","source","error","handle","context"]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,"vtkShader"),extend:pd};const{vtkErrorMacro:gd}=jt;function md(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(gd(`Links failed: ${t.error}`),0):(gd(t.error),0):(gd(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.fragmentShader.getError()),0):(gd(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return gd(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(gd("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return gd("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const hd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=fd.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=fd.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=fd.newInstance(),t.geometryShader.setShaderType("Geometry"),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),md(e,t)}var yd={newInstance:jt.newInstance(vd,"vtkShaderProgram"),extend:vd,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};function Td(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==Zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const bd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function xd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,["supported"]),jt.setGet(e,t,["forceEmulation"]),Td(e,t)}var Cd={newInstance:jt.newInstance(xd,"vtkOpenGLVertexArrayObject"),extend:xd};const Sd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function Ad(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===ss.POINTS||n===Sd.Points?t.context.POINTS:e===ss.WIREFRAME||n===Sd.Lines||n===Sd.TrisEdges||n===Sd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Sd.Points||r.getProperty().getRepresentation()===ss.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Sd.Points?2:t.primitiveType===Sd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const Id={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function wd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Id,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=yd.newInstance(),t.VAO=Cd.newInstance(),t.CABO=ld.newInstance(),Ad(e,t)}var Pd={newInstance:jt.newInstance(wd),extend:wd,primTypes:Sd};const Od={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Rd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var Md={Wrap:Od,Filter:Rd};const Ed=new Float32Array(1),Dd=new Int32Array(Ed.buffer);var Vd={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Ed[0]=e;const t=Dd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let Ld;const{Wrap:Bd,Filter:Nd}=Md,{VtkDataTypes:_d}=Ns,{vtkDebugMacro:Fd,vtkErrorMacro:kd,vtkWarningMacro:Gd}=Kt,{toHalf:Ud}=Vd;function zd(e,t){t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Nd.LINEAR),e.setMagnificationFilter(Nd.LINEAR)):(e.setMinificationFilter(Nd.NEAREST),e.setMagnificationFilter(Nd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Bd.REPEAT),e.setWrapS(Bd.REPEAT),e.setWrapT(Bd.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const n=()=>{if(t.minificationFilter!==Nd.LINEAR&&t.magnificationFilter!==Nd.LINEAR||(void 0===Ld&&(Ld=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,y=i.getExtension("WEBGL_lose_context");return y&&y.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),Ld))return t.oglNorm16Ext};function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension("OES_texture_half_float"),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Vd.toHalf(Vd.fromHalf(e[u][l+s+t])*h*(1-v)+Vd.fromHalf(e[u][l+p+t])*h*v+Vd.fromHalf(e[u][c+s+t])*m*(1-v)+Vd.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&n())||e!==_d.UNSIGNED_SHORT&&e!==_d.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Gd("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Fd(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Gd("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(r,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(r,o,n(),e.useHalfFloat()),a||(a||(Fd("Unsupported internal texture type!"),Fd(`Unable to find suitable internal format for T=${r} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=r=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case n()&&!o&&_d.SHORT:return t.context.SHORT;case n()&&!o&&_d.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&_d.SHORT:case o&&_d.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case _d.FLOAT:case _d.VOID:default:return t.context.FLOAT}switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case _d.FLOAT:case _d.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Nd.NEAREST:return t.context.NEAREST;case Nd.LINEAR:return t.context.LINEAR;case Nd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Nd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Nd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Nd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Bd.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Bd.REPEAT:return t.context.REPEAT;case Bd.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==_d.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==_d.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Ud(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=e.updateArrayDataTypeForGL(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(e.updateArrayDataTypeForGL(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=(r,a,i,s)=>(e.getOpenGLDataType(i),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?i===_d.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=r,t.height=a,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(i,n(),e.useHalfFloat()),e.deactivate(),!0):(kd("Failed to determine texture parameters."),!1)),e.create2DFromImage=r=>{if(e.getOpenGLDataType(_d.UNSIGNED_CHAR),e.getInternalFormat(_d.UNSIGNED_CHAR,4),e.getFormat(_d.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const a=!(t._openGLRenderWindow.getWebgl2()||Fo(r.width)&&Fo(r.height)),i=document.createElement("canvas");i.width=a?_o(r.width):r.width,i.height=a?_o(r.height):r.height,t.width=i.width,t.height=i.height;const s=i.getContext("2d");s.translate(0,i.height),s.scale(1,-1),s.drawImage(r,0,0,r.width,r.height,0,0,i.width,i.height);const l=i;return o(_d.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=l&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,l)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,l),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(_d.UNSIGNED_CHAR,n(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Ns.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.updateVolumeInfoForGL=(r,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(n()&&!i&&r===_d.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(n()&&!i&&r===_d.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(r===_d.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(r===_d.FLOAT||i&&(r===_d.SHORT||r===_d.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=(a,i,s,l,c,u)=>{let d=c,p=u;if(!e.updateVolumeInfoForGL(d,l)&&p){const e=a*i*s,n=structuredClone(t.volumeInfo),r=new Float32Array(e*l);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const c=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<l;e++)r[o]=(p[o]-n.offset[e])*c[e],o++;d=_d.FLOAT,p=r}if(e.getOpenGLDataType(d),e.getInternalFormat(d,l),e.getFormat(d,l),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const f=[p],g=r(e.updateArrayDataTypeForGL(d,f,!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(d)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=g[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,g[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,g[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(d,n(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Ns.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=[],g=[];for(let e=0;e<c;++e)f[e]=0,g[e]=1;if(t.volumeInfo={scale:g,offset:f,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw(n,r,i,c,u,d);const m=n*r*i,h=structuredClone(p);let v=(e,t,n,r,o)=>{e[t]=n},y=_d.UNSIGNED_CHAR;if(u===_d.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=_d.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=_d.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===_d.FLOAT||c>=3)&&(T=4096);let b=1,x=1;m>T*T&&(b=Math.ceil(Math.sqrt(m/(T*T))),x=b);let C=Math.sqrt(m)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===_d.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Wd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Bd.CLAMP_TO_EDGE,wrapT:Bd.CLAMP_TO_EDGE,wrapR:Bd.CLAMP_TO_EDGE,minificationFilter:Nd.NEAREST,magnificationFilter:Nd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,["format","openGLDataType"]),At(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),bt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),zd(e,t)}const jd=Dt(Hd,"vtkOpenGLTexture");var Kd={newInstance:jd,extend:Hd,...Md};rn("vtkTexture",jd);var $d="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",qd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",Xd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=yd.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},Yd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=yd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Zd}=ll,{primTypes:Qd}=Pd,{Representation:Jd,Shading:ep}=ms,{ScalarMode:tp}=uc,{Filter:np,Wrap:rp}=Kd,{vtkErrorMacro:op}=Kt,ap={type:"StartEvent"},ip={type:"EndEvent"},{CoordinateSystem:sp}=ts;function lp(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=yd.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=yd.substitute(i,"//VTK::Color::Impl",c).result):i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=yd.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=yd.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=yd.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:op("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=yd.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=yd.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=yd.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=yd.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=yd.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=yd.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=yd.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===Jd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===Qd.Points||o.getRepresentation()===Jd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===Qd.Lines||o.getRepresentation()===Jd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==Qd.Tris&&e!==Qd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==Qd.TrisEdges&&e!==Qd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=yd.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==$l.ID_LOW24&&t.lastSelectionState!==$l.ID_HIGH24||(a=yd.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=yd.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=yd.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=yd.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case $l.ID_LOW24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case $l.ID_HIGH24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=yd.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===ep.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||op(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||op("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||op("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===sp.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():$l.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Jd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===$l.ID_LOW24||t.lastSelectionState===$l.ID_HIGH24);for(let i=Qd.Start;i<Qd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===Qd.TrisEdges||i===Qd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(ip),!t.currentInput)return void op("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==tp.USE_CELL_DATA&&a!==tp.USE_CELL_FIELD_DATA&&a!==tp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===tp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==ep.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Kd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(np.NEAREST),e.setMagnificationFilter(np.NEAREST),e.setWrapS(rp.CLAMP_TO_EDGE),e.setWrapT(rp.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===Jd.SURFACE;for(let n=Qd.Start;n<Qd.End;n++)n!==Qd.TrisEdges&&n!==Qd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,Jd.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const cp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:$l.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=Qd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),lp(e,t)}const dp=Dt(up,"vtkOpenGLPolyDataMapper");var pp={newInstance:dp,extend:up};rn("vtkMapper",dp);const{ColorMode:fp,ScalarMode:gp,GetArray:mp}=bl;function hp(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(fp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(gp,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===gp.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===gp.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===gp.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===gp.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_FIELD_DATA){const t=e.getFieldData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const vp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),ks(e,t,n),jt.get(e,t,["colorMapColors"]),jt.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),hp(e,t)}var Tp={newInstance:jt.newInstance(yp,"vtkMapper2D"),extend:yp};const bp=1,{primTypes:xp}=Pd,{ScalarMode:Cp}=Tp,{vtkErrorMacro:Sp}=Kt,Ap={type:"StartEvent"},Ip={type:"EndEvent"};function wp(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=xp.Start;e<xp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(Ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Ip),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Sp("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Cp.USE_CELL_DATA&&a!==Cp.USE_CELL_FIELD_DATA&&a!==Cp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Cp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=Sc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[xp.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[xp.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[xp.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[xp.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=xp.Start;a<xp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=yd.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=yd.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=yd.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=yd.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=yd.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=yd.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=yd.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=yd.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=yd.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Sp("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Sp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Sp("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===bp?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Pp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Op=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=xp,t.tmpMat4=g(new Float64Array(16));for(let e=xp.Start;e<xp.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),wp(e,t)}),"vtkOpenGLPolyDataMapper2D");rn("vtkMapper2D",Op);const{VectorMode:Rp}=El;function Mp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Ep(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Vp(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Mp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Mp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Mp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,"horizontal",g,c)}const b=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Rp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ns.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Lp=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings"]),jt.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),jt.getArray(e,t,["boxPosition","boxSize"]),jt.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=uc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Cu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=bs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Vp(e,t)}),"vtkScalarBarActorHelper");function Bp(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Ep(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dp())}}function Np(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Np(n)),t.autoLayout||(t.autoLayout=Ep(0,t)),t.generateTicks||(t.generateTicks=Dp()),bs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),jt.get(e,t,["axisTextStyle","tickTextStyle"]),jt.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),jt.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),Bp(e,t)}var Fp={newInstance:jt.newInstance(_p,"vtkScalarBarActor"),extend:_p,newScalarBarActorHelper:Lp};function kp(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gp={};const Up=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Fp.newScalarBarActorHelper(),kp(e,t)}),"vtkOpenGLScalarBarActor");rn("vtkScalarBarActor",Up);const{vtkErrorMacro:zp}=Kt;function Wp(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ns.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||zp("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||zp("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Hp={context:null};const jp=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hp,n),Zt.extend(e,t,n),t.openGLTexture=Kd.newInstance(),t.tris=Pd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),Wp(e,t)}));rn("vtkSkybox",jp);const{FieldAssociations:Kp}=ll;function $p(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const qp={fieldAssociation:Kp.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Xp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),jt.obj(e,t),jt.setGet(e,t,["fieldAssociation","captureZValues"]),$p(e,t)}var Yp={newInstance:jt.newInstance(Xp,"vtkHardwareSelector"),extend:Xp};function Zp(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et("Attaching depth buffer textures to fbo requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et("Attaching depth buffer textures to framebuffers requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Kd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Rd.LINEAR),r.setMagnificationFilter(Rd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,Cs.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const Qp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qp,n),yt(e,t),t.colorBuffers&&et("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],It(e,t,["colorBuffers"]),Zp(e,t)}var ef={newInstance:Dt(Jp,"vtkFramebuffer"),extend:Jp};function tf(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}const nf={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function rf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nf,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,["contentType","fieldType","properties","selectionList"]),tf(e,t)}var of={newInstance:jt.newInstance(rf,"vtkSelectionNode"),extend:rf,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:af}=ql,{SelectionContent:sf,SelectionField:lf}=of,{FieldAssociations:cf}=ll,{vtkErrorMacro:uf}=jt;function df(e){return`${e.propID} ${e.compositeID}`}function pf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ff(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function gf(e,t){let n=t;return n<<=24,n|=e,n}function mf(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ff(n[0],n[1],e.pixBuffer[af.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ff(n[0],n[1],e.pixBuffer[af.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[af.ID_LOW24]&&0===pf(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area))return a;const s=ff(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area),l=ff(n[0],n[1],e.pixBuffer[af.ID_HIGH24],e.area);return a.attributeID=gf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=mf(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=mf(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=mf(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function hf(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=of.newInstance();switch(l.setContentType(sf.INDICES),e){case cf.FIELD_ASSOCIATION_CELLS:l.setFieldType(lf.CELL);break;case cf.FIELD_ASSOCIATION_POINTS:l.setFieldType(lf.POINT);break;default:uf("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function vf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=mf(e,[n,t],0,u);if(r&&r.valid){const t=df(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return hf(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function yf(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return vf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return uf("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=af.MIN_KNOWN_PASS;t.currentPass<=af.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===af.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=af.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===af.ID_HIGH24){if(t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===cf.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===af.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ff(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===af.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===af.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(af,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ff(e[0],e[1],t.pixBuffer[af.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ff(e[0],e[1],t.pixBuffer[af.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[af.ID_LOW24]&&0===pf(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area))return a;const s=ff(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area),l=ff(e[0],e[1],t.pixBuffer[af.ID_HIGH24],t.area);return a.attributeID=gf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=df(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return hf(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const Tf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Yp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,["area"],4),jt.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),jt.setGetArray(e,t,["propColorValue"],3),jt.moveToProtected(e,t,["renderer","openGLRenderWindow"]),jt.event(e,t,"event"),yf(e,t)}var xf={newInstance:jt.newInstance(bf,"vtkOpenGLHardwareSelector"),extend:bf,...ql};const{vtkErrorMacro:Cf}=Kt,{Representation:Sf}=ms,{ObjectType:Af}=rd,{PassTypes:If}=xf,wf={type:"StartEvent"},Pf={type:"EndEvent"};function Of(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(wf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(Pf),!t.currentInput)return void Cf("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=yd.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=yd.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=yd.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=yd.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=yd.substitute(o,"//VTK::Color::Impl",s).result,o=yd.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=yd.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=yd.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=yd.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=yd.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===Sf.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===If.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||Cf("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||Cf("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=rd.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=rd.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=rd.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=rd.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,Af.ARRAY_BUFFER),t.normalBuffer.upload(n,Af.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),Af.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,Af.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Rf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Mf=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),pp.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),Of(e,t)}),"vtkOpenGLGlyph3DMapper");rn("vtkGlyph3DMapper",Mf);const{vtkErrorMacro:Ef}=jt;class Df{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Vf(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Ef("Invalid or missing input");const r=Cu.newInstance();r.shallowCopy(n);const o=new Df,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(vc.newInstance({values:c,name:"faces"})),t[0]=r}}const Lf={};function Bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lf,n),jt.obj(e,t),jt.algo(e,t,1,1),Vf(e,t)}var Nf={newInstance:jt.newInstance(Bf,"vtkClosedPolyLineToSurfaceFilter"),extend:Bf};const{vtkErrorMacro:_f}=Kt;function Ff(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void _f("Invalid or missing input");if(!t.cutFunction)return void _f("Missing cut function");const o=Cu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const kf={cutFunction:null,cutScalars:null,cutValue:0};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kf,n),yt(e,t),Rt(e,t,1,1),At(e,t,["cutFunction","cutValue"]),Ff(e,t)}var Uf={newInstance:Dt(Gf,"vtkCutter"),extend:Gf};const zf=e=>e,Wf=1e-6;class Hf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:zf}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=En(n,r);return a>=1||(Dn(this.tmp,n,r),Sn(this.tmp)<Wf&&(Dn(this.tmp,[1,0,0],e),Sn(this.tmp)<Wf&&Dn(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var jf=function(){return new Hf(!0)},Kf=function(){return new Hf(!1)};const $f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],qf=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function Xf(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Cu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Ns.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Ns.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&jf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Kf().translate(...t.center).apply(o),t.matrix){Kf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Kf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Yf={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),jt.setGetArray(e,t,["center","rotations"],3),jt.setGetArray(e,t,["matrix"],16),t._polys=vc.newInstance({values:Uint16Array.from(qf)}),t._lineCells=vc.newInstance({values:Uint16Array.from($f)}),jt.moveToProtected(e,t,["polys","lineCells"]),jt.algo(e,t,0,1),Xf(e,t)}var Qf={newInstance:jt.newInstance(Zf,"vtkCubeSource"),extend:Zf};const{vtkErrorMacro:Jf}=jt;function eg(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Jf("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Jf("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const tg={};function ng(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tg,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=Qf.newInstance(),jt.moveToProtected(e,t,["cubeSource","tmpOut"]),eg(e,t)}var rg={newInstance:jt.newInstance(ng,"vtkImageDataOutlineFilter"),extend:ng};let og;function ag(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>og({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const ig={preMultiplyFlag:!1,matrix:[...vo]};function sg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),jt.obj(e,t),jt.setGet(e,t,["preMultiplyFlag"]),jt.setGetArray(e,t,["matrix"],16),ag(e,t)}og=jt.newInstance(sg,"vtkTransform");var lg={newInstance:og,extend:sg};function cg(e,t,n){return e?`${e.getMTime()}-${t}-${n}`:"0"}function ug(e,t){return`${e.getMTime()}A${t.getMTime()}`}const dg={NEAREST:0,LINEAR:1};var pg={InterpolationType:dg};const{vtkErrorMacro:fg}=Kt;function gg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function mg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageResliceMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera());const o=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),o&&!o.isDeleted()&&o!==t._openGLRenderWindow&&n(o),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})):fg("No input!")},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.openGLTexture.setMinificationFilter(Rd.LINEAR),t.openGLTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()?.getScalars();if(!a)return;const i=a.getNumberOfComponents();let s=ug(o,a);const l=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(l?.oglObject?.getHandle()&&l?.hash===s)t.openGLTexture=l.oglObject;else{t.openGLTexture=Kd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a),t._openGLRenderWindow.setGraphicsResourceForObject(a,t.openGLTexture,s),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a}const c=r.getProperty(),u=c.getIndependentComponents(),d=u?i:1,p=u?2*d:1,f=c.getRGBTransferFunction();s=cg(f,u,d);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===s)t.colorTexture=g.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*p*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=c.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,s),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const m=c.getPiecewiseFunction();s=cg(m,u,d);const h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===s)t.pwfTexture=h.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),m){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=c.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.pwfTexture,s),m!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=m)}const v=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==v){const e=Ns.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ns.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:fg("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",ss.SURFACE,r)}t.VBOBuildString=v,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed("texture1")&&a.setUniformi("texture1",t.openGLTexture.getTextureUnit()),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",t.currentInput.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",gg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",gg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=yd.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=["in vec3 fragTexCoord;","uniform highp sampler3D texture1;","uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:fg("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=yd.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(texture1, fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:fg("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=yd.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=yd.substitute(a,"//VTK::PositionVC::Impl",u).result,a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=yd.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ii.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();za.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ns.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Cu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ns.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else fg("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const hg={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1};const vg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=rg.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Cu.newInstance(),t.cutter=Uf.newInstance(),t.lineToSurfaceFilter=Nf.newInstance(),t.transform=lg.newInstance(),bt(e,t,["openGLTexture"]),mg(e,t)}),"vtkOpenGLImageResliceMapper");rn("vtkImageResliceMapper",vg);var yg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:Tg}=Kt,{SlicingMode:bg}=yg;function xg(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function Cg(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=yd.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=yd.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Tg("Unsupported number of independent coordinates.")}}if(i=yd.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=yd.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=yd.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Tg("Unsupported number of independent coordinates.")}i=yd.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=yd.substitute(i,"//VTK::TCoord::Impl",[...xg("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Tg("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||Tg("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===bg.NONE&&(i=bg.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Tg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=cg(f,u,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.oglObject?.getHandle()&&m?.hash===g)t.colorTexture=m.oglObject;else{t.colorTexture=Kd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(n*p*3);if(c===dg.NEAREST?(t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST)):(t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR)),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,g),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const h=l.getPiecewiseFunction(),v=cg(h,u,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.oglObject?.getHandle()&&y?.hash===v)t.pwfTexture=y.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===dg.NEAREST?(t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),h){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);h&&(t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,v),h!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(h,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=h)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===bg.I&&(S=x-C[0]),T===bg.J&&(S=x-C[2]),T!==bg.K&&T!==bg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Kd.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===dg.NEAREST?(new Set([1,3,4]).has(s)&&i===Cs.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.NEAREST)):t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST)):(4!==s||i!==Cs.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Rd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Rd.LINEAR)),t.openGLTexture.setWrapS(Od.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Od.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[bg.X,bg.Y,bg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===bg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===bg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===bg.K||T===bg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):Tg("Reformat slicing not yet supported.");t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const m=Ns.newInstance({numberOfComponents:3,values:r});m.setName("points");const h=Ns.newInstance({numberOfComponents:2,values:l});h.setName("tcoords");const v=new Uint16Array(8);v[0]=3,v[1]=0,v[2]=1,v[3]=3,v[4]=3,v[5]=0,v[6]=3,v[7]=2;const y=Ns.newInstance({numberOfComponents:1,values:v});t.tris.getCABO().createVBO(y,"polys",ss.SURFACE,{points:m,tcoords:h,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Kd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Sg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const Ag=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),Cg(e,t)}),"vtkOpenGLImageMapper");rn("vtkAbstractImageMapper",Ag);const Ig=0,wg=1,Pg=2,{vtkErrorMacro:Og}=jt;function Rg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.volumeTexture.setMinificationFilter(Rd.NEAREST),t.volumeTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.volumeTexture.setMinificationFilter(Rd.LINEAR),t.volumeTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=o?.getPointData()?.getScalars();if(!i)return;const s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=ug(o,i);if(s?.oglObject?.getHandle()&&s?.hash===l)t.volumeTexture=s.oglObject;else{t.volumeTexture=Kd.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],i,t.renderable.getPreferSizeOverAccuracy()),t._openGLRenderWindow.setGraphicsResourceForObject(i,t.volumeTexture,l),i!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(i,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=i}const c=i.getNumberOfComponents(),u=r.getProperty(),d=u.getIndependentComponents(),p=d?c:1,f=d?2*p:1,g=u.getRGBTransferFunction(),m=cg(g,d,p),h=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(h?.oglObject?.getHandle()&&h?.hash===m)t.colorTexture=h.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*f*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),g){const e=new Float32Array(3*n);for(let t=0;t<p;t++){const o=u.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),d)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,f,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}g&&(t._openGLRenderWindow.setGraphicsResourceForObject(g,t.colorTexture,m),g!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(g,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=g)}const v=u.getPiecewiseFunction(),y=cg(v,d,p),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===y)t.pwfTexture=T.oglObject;else{const n=1024,r=n*f,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),v){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<p;++t){const r=u.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),d)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,f,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);v&&(t._openGLRenderWindow.setGraphicsResourceForObject(v,t.pwfTexture,y),v!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(v,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=v)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ns.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ns.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ns.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Ns.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ns.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ns.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});y.push(a,s)}t.tris.getCABO().createVBO(d,"polys",ss.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Og("Unsupported number of independent coordinates.")}}i=yd.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===wg?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case Ig:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case wg:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===Pg&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Og("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||Og("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&Og(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=P(new Float32Array(16),Rn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),T(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=jt.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Mg={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Eg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mg,n),Zt.extend(e,t,n),Xd(e,t,n),jt.algo(e,t,2,0),t.tris=Pd.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),Rg(e,t)}),"vtkOpenGLImageCPRMapper");function Dg(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkImageCPRMapper",Eg);const Vg={context:null,keyMatrixTime:null,keyMatrices:null};const Lg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,["context"]),Dg(e,t)}),"vtkOpenGLImageSlice");function Bg(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn("vtkImageSlice",Lg);const Ng={};const _g=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ng,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,["context"]),Bg(e,t)}),"vtkOpenGLVolume");rn("vtkVolume",_g);const Fg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},kg={FRACTIONAL:0,PROPORTIONAL:1},Gg={CUSTOM:0,ADDITIVE:1,COLORIZE:2};var Ug={InterpolationType:Fg,OpacityMode:kg,ColorMixPreset:Gg};const zg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var Wg={BlendMode:zg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Hg,vtkErrorMacro:jg}=Kt;function Kg(e,t){function n(n){[t._scalars,t._scalarOpacityFunc,t._colorTransferFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLVolumeMapper"),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(r,o)=>{if(r){const r=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const o=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const a=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(a.getActiveCamera()),e.renderPiece(a,o)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define UseIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define vtkCustomComponentsColorMix\n//VTK::CustomComponentsColorMixOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// possibly define any components that are forced to nearest interpolation\n//VTK::vtkForceNearestComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Possibly define vtkLabelEdgeProjectionOn\n//VTK::LabelEdgeProjectionOn\n\n\n#ifdef vtkImageLabelOutlineOn\n  uniform float outlineOpacity;\n  uniform float vpWidth;\n  uniform float vpHeight;\n  uniform float vpOffsetX;\n  uniform float vpOffsetY;\n  uniform mat4 PCWCMatrix;\n  uniform mat4 vWCtoIDX;\n\n  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];\n  #define MAX_SEGMENTS 256\n  #define UINT_SIZE 32\n  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\n\n  uint bitmask[BITMASK_SIZE];\n\n  // Set the corresponding bit in the bitmask\n  void setBit(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    bitmask[index] |= 1u << bitIndex;\n  }\n\n  // Check if a bit is set in the bitmask\n  bool isBitSet(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    return ((bitmask[index] & (1u << bitIndex)) != 0u);\n  }\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#ifdef UseIndependentComponents\n#if vtkNumComponents > 1\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents > 2\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#if vtkNumComponents > 3\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\nuniform vec3 volumeSpacings; // spacing in the world coorindates\n\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef UseIndependentComponents\n#if vtkNumComponents == 1\nuniform float mix0;\n#define height0 0.5\n#endif\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);\n    vec4 nearestValue = texture(texture1, nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  #ifndef UseIndependentComponents\n    #if vtkNumComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n  #ifdef vtkClippingPlanesOn\n    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n    {\n      vec3 g1VC[3];\n      for (int i = 0; i < 3; ++i)\n      {\n        g1VC[i] = IStoVC(texPos[i]);\n      }\n      vec3 posVC = IStoVC(pos);\n      for (int i = 0; i < clip_numPlanes; ++i)\n      {\n        for (int j = 0; j < 3; ++j)\n        {\n          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n          {\n            g1[j] = 0.0;\n          }\n        }\n      }\n    }\n  #endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {\n      vec3 opacityG1, opacityG2;\n      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;\n      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;\n      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;\n      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;\n      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;\n      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;\n      opacityG1.xyz *= gradientOpacity;\n      opacityG2.xyz *= gradientOpacity;\n\n      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n      // divide by spacing\n      opacityG.xyz /= vSpacing;\n      opacityG.w = length(opacityG.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(opacityG.xyz);\n      if (!all(equal(opacityG.xyz, vec3(0.0)))) {\n        return vec4(normalize(opacityG.xyz),opacityG.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n\n    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)\n    {\n      vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n      vec3 yvec = vec3(0.0, tstep.y, 0.0);\n      vec3 zvec = vec3(0.0, 0.0, tstep.z);\n      vec3 texPosPVec[3];\n      texPosPVec[0] = pos + xvec;\n      texPosPVec[1] = pos + yvec;\n      texPosPVec[2] = pos + zvec;\n      vec3 texPosNVec[3];\n      texPosNVec[0] = pos - xvec;\n      texPosNVec[1] = pos - yvec;\n      texPosNVec[2] = pos - zvec;\n      vec3 g1, g2;\n\n      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];\n      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];\n      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];\n      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];\n      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];\n      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];\n\n      #ifdef vtkClippingPlanesOn\n        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n      #endif\n      vec4 result;\n      result.x = scalarInterp[0].x - scalarInterp[1].x;\n      result.y = scalarInterp[0].y - scalarInterp[1].y;\n      result.z = scalarInterp[0].z - scalarInterp[1].z;\n      // divide by spacing\n      result.xyz /= vSpacing;\n      result.w = length(result.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      if (length(result.xyz) > 0.0) {\n        return vec4(normalize(result.xyz),result.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n  #endif\n\n  // only works with dependent components\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n\n#ifdef vtkImageLabelOutlineOn\n  vec4 fragCoordToPCPos(vec4 fragCoord) {\n    return vec4(\n      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n      (fragCoord.z - 0.5) * 2.0,\n      1.0);\n  }\n\n  vec4 pcPosToWorldCoord(vec4 pcPos) {\n    return PCWCMatrix * pcPos;\n  }\n\n  vec3 fragCoordToIndexSpace(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    vec4 vertex = (worldCoord / worldCoord.w);\n\n    vec3 index = (vWCtoIDX * vertex).xyz;\n\n    // half voxel fix for labelmapOutline\n    return (index + vec3(0.5)) / vec3(volumeDimensions);\n  }\n\n  vec3 fragCoordToWorld(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    return worldCoord.xyz;\n  }\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)\n      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {\n  #if vtkLightComplexity > 0\n    // surface shadows if needed\n    #ifdef SurfaceShadowOn\n      #if vtkLightComplexity < 3\n        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);\n      #else\n        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));\n      #endif\n    #endif\n\n    // volume shadows if needed\n    #ifdef VolumeShadowOn\n      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);\n    #endif\n\n    // merge\n    #ifdef VolumeShadowOn\n      #ifdef SurfaceShadowOn\n        // surface shadows + volumetric shadows\n        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n      #else\n        // volumetric shadows only\n        tColor = tColorVS;\n      #endif\n    #else\n      #ifdef SurfaceShadowOn\n        // surface shadows only\n        tColor = tColorS;\n      #else\n        // no shadows\n        applyLighting(tColor, normal3);\n      #endif\n    #endif\n  #endif\n  return tColor;\n}\n\n  \nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n\n// If labeloutline and not the edge labelmap, since in the edge labelmap blend\n// we need the underlying data to sample through\n#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n\n  // If it is the background (segment index 0), we should quickly bail out. \n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0){\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n        gl_FragCoord.y + float(j),\n        gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = outlineOpacity;\n  }\n\n  return tColor;\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n\n  #ifdef UseIndependentComponents\n\n    // sample textures\n    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n\n    #if vtkNumComponents > 1\n      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n\n      #if vtkNumComponents > 2\n        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n\n        #if vtkNumComponents > 3\n          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #endif\n      #endif\n    #endif\n\n    #if !defined(vtkCustomComponentsColorMix)\n      // default path for component color mix\n\n      // compute the normal vectors as needed\n      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #endif\n\n      // compute gradient opacity factors as needed\n      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);\n      #if defined(vtkGradientOpacityOn)\n        #if !defined(vtkComponent0Proportional)\n          goFactor.x =\n            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n        #endif\n        #if vtkNumComponents > 1\n          #if !defined(vtkComponent1Proportional)\n            goFactor.y =\n              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          #endif\n          #if vtkNumComponents > 2\n            #if !defined(vtkComponent2Proportional)\n              goFactor.z =\n                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);\n            #endif\n            #if vtkNumComponents > 3\n              #if !defined(vtkComponent3Proportional)\n                goFactor.w =\n                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);\n              #endif\n            #endif\n          #endif\n        #endif\n      #endif\n\n      // process color and opacity for each component\n      #if !defined(vtkComponent0Proportional)\n        float alpha = goFactor.x*mix0*pwfValue0;\n        #if vtkLightComplexity > 0\n          applyLighting(tColor0, normalMat[0]);\n        #endif\n      #else\n        tColor0 *= pwfValue0;\n        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));\n      #endif\n\n      #if vtkNumComponents > 1\n        #if !defined(vtkComponent1Proportional)\n          alpha += goFactor.y*mix1*pwfValue1;\n          #if vtkLightComplexity > 0\n            applyLighting(tColor1, normalMat[1]);\n          #endif\n        #else\n          tColor1 *= pwfValue1;\n          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));\n        #endif\n\n        #if vtkNumComponents > 2\n          #if !defined(vtkComponent2Proportional)\n            alpha += goFactor.z*mix2*pwfValue2;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor2, normalMat[2]);\n            #endif\n          #else\n            tColor2 *= pwfValue2;\n            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));\n          #endif\n        #endif\n\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            alpha += goFactor.w*mix3*pwfValue3;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor3, normalMat[3]);\n            #endif\n          #else\n            tColor3 *= pwfValue3;\n            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));\n          #endif\n        #endif\n      #endif\n\n      // perform final independent blend\n      vec3 tColor = mix0 * tColor0;\n      #if vtkNumComponents > 1\n        tColor += mix1 * tColor1;\n        #if vtkNumComponents > 2\n          tColor += mix2 * tColor2;\n          #if vtkNumComponents > 3\n            tColor += mix3 * tColor3;\n          #endif\n        #endif\n      #endif\n\n      return vec4(tColor, alpha);\n    #else\n      /*\n       * Mix the color information from all the independent components to get a single rgba output\n       * Gradient opactity factors and normals are not computed\n       *\n       * You can compute these using:\n       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix\n       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),\n       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper\n       * - computeGradientOpacityFactor: always available, used in a lot of places\n       *\n       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)\n       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight\n       */\n      //VTK::CustomComponentsColorMix::Impl\n    #endif\n  #else\n    // dependent components\n\n    // compute normal if needed\n    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n      #endif\n    #endif\n\n    // compute gradient opacity factor enabled\n    #if defined(vtkGradientOpacityOn)\n      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #else\n      const float gradientOpacity = 1.0;\n    #endif\n\n    // get color and opacity\n    #if vtkNumComponents == 1\n      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      if (alpha < EPSILON){\n        return vec4(0.0);\n      }\n    #endif\n    #if vtkNumComponents == 2\n      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 3\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 4\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n    #endif\n\n    // lighting\n    #if (vtkLightComplexity > 0)\n      #ifdef vtkComputeNormalFromOpacity\n        vec4 normalLight;\n        if (!all(equal(normal0, vec4(0.0)))) {\n          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;\n          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;\n          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);\n          if (all(equal(normalLight, vec4(0.0)))) {\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normalLight = normal0;\n      #endif\n      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);\n    #endif\n\n    return vec4(tColor, alpha);\n  #endif // dependent\n#endif\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #else\n    #ifdef UseIndependentComponents\n      #if vtkNumComponents == 2\n        if (val.r >= min.r && val.r <= max.r &&\n            val.g >= min.g && val.g <= max.g) {\n          withinRange = true;\n        }\n      #else\n        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n            all(lessThanEqual(val, ipScalarRangeMax))) {\n          withinRange = true;\n        }\n      #endif\n    #endif\n  #endif\n  return withinRange;\n}\n\n#if vtkBlendMode == 6 \nbool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    bool justSawIt = false;\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n\n    float stepsTraveled = 0.0;\n\n\n    // float neighborValue;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS += stepIS;\n    }\n\n    if (justSawIt){\n      return false;\n    }\n\n   \n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS -= stepIS;\n    }\n\n\n    if (!justSawIt) {\n        // onedge\n        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;\n        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;\n        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n        return true;\n    }\n\n    // not on edge\n    return false;\n}\n\n#endif\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // Initialize arrays to false\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n  \n  #if vtkBlendMode == 6 \n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    uint bitmask = 0u;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading \n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the segment index\n      // and later check if the bit is set via bit operations\n      setBit(segmentIndex);\n    }\n    \n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value =  tValue; // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue; // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }  \n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);\n      return;\n    }\n\n    // probably we can make this configurable but for now we will use the same\n    // sample distance as the original sample distance\n    float neighborSampleDistanceIS = sampleDistanceIS;\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not \n      // been seen by the center segment\n      if (!isBitSet(s)) {\n       continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have \n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out \n      // faster if we find the edge\n      bool onEdge =\n          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than \n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety \n      // of the all the fragments inside. i.e., this happens when we zoom out, \n      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n      \n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n            for (int j = -actualThickness; j <= actualThickness; j++) {\n                if (i == 0 && j == 0) continue; // Skip the center\n                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners\n                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {\n                    return;\n                }\n          }\n      }\n    }\n\n    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n",e.Geometry=""},e.useIndependentComponents=e=>{const n=e.getIndependentComponents(),r=t.currentInput?.getPointData()?.getScalars()?.getNumberOfComponents(),o=e.getColorMixPreset();return n&&r>=2||!!o},e.replaceShaderValues=(n,r,o)=>{const a=o.getProperty();let i=n.Fragment;a.getInterpolationType()===Fg.LINEAR&&(i=yd.substitute(i,"//VTK::TrilinearOn","#define vtkTrilinearOn").result),!0===e.isLabelmapOutlineRequired(o)&&(i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result),t.renderable.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND&&(i=yd.substitute(i,"//VTK::LabelEdgeProjectionOn","#define vtkLabelEdgeProjectionOn").result);const s=t.scalarTexture.getComponents();i=yd.substitute(i,"//VTK::NumComponents",`#define vtkNumComponents ${s}`).result;const l=e.useIndependentComponents(a);l&&(i=yd.substitute(i,"//VTK::IndependentComponentsOn","#define UseIndependentComponents").result);const c=[],u=[];for(let e=0;e<s;e++)a.getOpacityMode(e)===kg.PROPORTIONAL&&c.push(`#define vtkComponent${e}Proportional`),a.getForceNearestInterpolation(e)&&u.push(`#define vtkComponent${e}ForceNearest`);i=yd.substitute(i,"//VTK::vtkProportionalComponents",c.join("\n")).result,i=yd.substitute(i,"//VTK::vtkForceNearestComponents",u.join("\n")).result;const d=function(e){switch(e){case Gg.CUSTOM:return"//VTK::CustomColorMix";case Gg.ADDITIVE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n\n          vec3 scalarInterp1[2];\n          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);\n          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;\n          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;\n          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n          vec4 normalLight1 = normalMat[1];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        float opacity1 = pwfValue1;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          opacity1 *= gof1;\n        #endif\n        float opacitySum = opacity0 + opacity1;\n        if (opacitySum <= 0.0) {\n          return vec4(0.0);\n        }\n\n        // mix the colors and opacities\n        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);\n        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);\n        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;\n        return vec4(mixedColor, min(1.0, opacitySum));\n";case Gg.COLORIZE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n        #endif\n\n        // mix the colors and opacities\n        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);\n        color = applyAllLightning(color, opacity0, posIS, normalLight0);\n        return vec4(color, opacity0);\n";default:return null}}(a.getColorMixPreset());d&&(i=yd.substitute(i,"//VTK::CustomComponentsColorMixOn","#define vtkCustomComponentsColorMix").result,i=yd.substitute(i,"//VTK::CustomComponentsColorMix::Impl",d).result);const p=t.currentInput.getSpatialExtent(),f=t.currentInput.getSpacing(),g=new Float64Array(3);In(g,(p[1]-p[0])*f[0],(p[3]-p[2])*f[1],(p[5]-p[4])*f[2]);const m=Sn(g)/e.getCurrentSampleDistance(r);i=yd.substitute(i,"//VTK::MaximumSamplesValue",`${Math.ceil(m)}`).result,i=yd.substitute(i,"//VTK::LightComplexity",`#define vtkLightComplexity ${t.lightComplexity}`).result,t.lightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(i=yd.substitute(i,"//VTK::VolumeShadowOn","#define VolumeShadowOn").result),t.renderable.getVolumetricScatteringBlending()<1&&(i=yd.substitute(i,"//VTK::SurfaceShadowOn","#define SurfaceShadowOn").result),t.renderable.getLocalAmbientOcclusion()&&a.getAmbient()>0&&(i=yd.substitute(i,"//VTK::localAmbientOcclusionOn","#define localAmbientOcclusionOn").result));const h=l?s:1;t.gopacity=!1;for(let e=0;!t.gopacity&&e<h;++e)t.gopacity||=a.getUseGradientOpacity(e);t.gopacity&&(i=yd.substitute(i,"//VTK::GradientOpacityOn","#define vtkGradientOpacityOn").result),t.renderable.getComputeNormalFromOpacity()&&(i=yd.substitute(i,"//VTK::vtkComputeNormalFromOpacity","#define vtkComputeNormalFromOpacity").result),null!==t.zBufferTexture&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDir.z;","dists.y = min(zdepth,dists.y);"]).result),i=yd.substitute(i,"//VTK::BlendMode",`${t.renderable.getBlendMode()}`).result,n.Fragment=i,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=yd.substitute(o,"//VTK::Light::Dec",["uniform int lightNum;","uniform bool twoSidedLighting;",`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,"//VTK::Light::Dec"],!1).result,3===t.lightComplexity&&(o=yd.substitute(o,"//VTK::Light::Dec",[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=yd.substitute(o,"//VTK::VolumeShadow::Dec",["uniform float volumetricScatteringBlending;","uniform float giReach;","uniform float volumeShadowSamplingDistFactor;","uniform float anisotropy;","uniform float anisotropy2;"],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=yd.substitute(o,"//VTK::LAO::Dec",["uniform int kernelRadius;",`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,"uniform int kernelSize;"],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=yd.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=yd.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${e}; i++) {`,"  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{const a=o.getProperty();((n,r)=>{let o=0;n.getProperty().getShade()&&t.renderable.getBlendMode()===zg.COMPOSITE_BLEND&&(o=0,t.numberOfLights=0,r.forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===o&&(o=1)),1===o&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(o=2),o<3&&e.getPositional()&&(o=3)}))),o!==t.lightComplexity&&(t.lightComplexity=o,e.modified())})(o,r.getLights());const i=t.scalarTexture.getComponents(),s=[],l=[];for(let e=0;e<i;e++)s.push(a.getOpacityMode(e)),l.push(a.getForceNearestInterpolation(e));const c=t.currentInput.getSpatialExtent(),u=t.currentInput.getSpacing(),d=new Float64Array(3);In(d,(c[1]-c[0])*u[0],(c[3]-c[2])*u[1],(c[5]-c[4])*u[2]);const p=Sn(d)/e.getCurrentSampleDistance(r),f=!!t.zBufferTexture,g={iComps:a.getIndependentComponents(),colorMixPreset:a.getColorMixPreset(),interpolationType:a.getInterpolationType(),useLabelOutline:e.isLabelmapOutlineRequired(o),numComp:i,maxSamples:p,useGradientOpacity:a.getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),hasZBufferTexture:f,opacityModes:s,forceNearestInterps:l};return(0===n.getProgram()?.getHandle()||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime()||!t.previousState||!ke()(t.previousState,g))&&(t.previousState=g,!0)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified()),a.setUniformi("texture1",t.scalarTexture.getTextureUnit()),a.setUniformf("sampleDistance",e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange();if(i?.dataComputedScale?.length){const e=[],t=[];for(let n=0;n<4;n++)e[n]=s[0]*i.dataComputedScale[n]+i.dataComputedOffset[n],t[n]=s[1]*i.dataComputedScale[n]+i.dataComputedOffset[n],e[n]=(e[n]-i.offset[n])/i.scale[n],t[n]=(t[n]-i.offset[n])/i.scale[n];a.setUniform4f("ipScalarRangeMin",e[0],e[1],e[2],e[3]),a.setUniform4f("ipScalarRangeMax",t[0],t[1],t[2],t[3])}if(null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf("camThick",c[1]-c[0]),s.setUniformf("camNear",c[0]),s.setUniformf("camFar",c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf("dcxmin",g),s.setUniformf("dcxmax",m),s.setUniformf("dcymin",v),s.setUniformf("dcymax",y),s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f("vSpacing",x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f("vOriginVC",p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Hg(`The number of steps required ${Math.ceil(A)} is larger than the\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f("vVCToIJK",I[0],I[1],I[2]),s.setUniform3i("volumeDimensions",d[0],d[1],d[2]),s.setUniform3f("volumeSpacings",x[0],x[1],x[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf("texWidth",t.scalarTexture.getWidth()),s.setUniformf("texHeight",t.scalarTexture.getHeight()),s.setUniformi("xreps",e.xreps),s.setUniformi("xstride",e.xstride),s.setUniformi("ystride",e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*En(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(e.isLabelmapOutlineRequired(o)){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix("vWCtoIDX",n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf("vpWidth",u[0]),s.setUniformf("vpHeight",u[1]);const d=e.getRenderTargetOffset();s.setUniformf("vpOffsetX",d[0]/u[0]),s.setUniformf("vpOffsetY",d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix("PCVCMatrix",t.projectionToView),0===t.lightComplexity)return;let O=0;const R=[],M=[],E=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],E[0+3*O]=-.5*w[0],E[1+3*O]=-.5*w[1],E[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi("twoSidedLighting",r.getTwoSidedLighting()),s.setUniformi("lightNum",O),s.setUniform3fv("lightColor",R),s.setUniform3fv("lightDirectionVC",M),s.setUniform3fv("lightHalfAngleVC",E),3===t.lightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv("lightPositionVC",e),s.setUniform3fv("lightAttenuation",n),s.setUniformfv("lightConeAngle",o),s.setUniformfv("lightExponent",a),s.setUniformiv("lightPositional",i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf("giReach",t.renderable.getGlobalIlluminationReach()),s.setUniformf("volumetricScatteringBlending",t.renderable.getVolumetricScatteringBlending()),s.setUniformf("volumeShadowSamplingDistFactor",t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf("anisotropy",t.renderable.getAnisotropy()),s.setUniformf("anisotropy2",t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi("kernelSize",e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv("kernelSample",n),s.setUniformi("kernelRadius",t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(n,r,o)=>{const a=n.getProgram();a.setUniformi("ctexture",t.colorTexture.getTextureUnit()),a.setUniformi("otexture",t.opacityTexture.getTextureUnit()),a.setUniformi("jtexture",t.jitterTexture.getTextureUnit()),a.setUniformi("ttexture",t.labelOutlineThicknessTexture.getTextureUnit());const i=t.scalarTexture.getVolumeInfo(),s=o.getProperty(),l=t.scalarTexture.getComponents(),c=e.useIndependentComponents(s);if(c)for(let e=0;e<l;e++)a.setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));for(let e=0;e<l;e++){const t=c?e:0,n=i.scale[e],r=s.getScalarOpacity(t).getRange(),o=n/(r[1]-r[0]),l=(i.offset[e]-r[0])/(r[1]-r[0]);a.setUniformf(`oshift${e}`,l),a.setUniformf(`oscale${e}`,o);const u=s.getRGBTransferFunction(t).getRange(),d=(i.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);a.setUniformf(`cshift${e}`,d),a.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(c)for(let e=0;e<l;++e){const t=i.scale[e];if(s.getUseGradientOpacity(e)){const n=s.getGradientOpacityMinimumOpacity(e),r=s.getGradientOpacityMaximumOpacity(e);a.setUniformf(`gomin${e}`,n),a.setUniformf(`gomax${e}`,r);const o=[s.getGradientOpacityMinimumValue(e),s.getGradientOpacityMaximumValue(e)];a.setUniformf(`goscale${e}`,t*(r-n)/(o[1]-o[0])),a.setUniformf(`goshift${e}`,-o[0]*(r-n)/(o[1]-o[0])+n)}else a.setUniformf(`gomin${e}`,1),a.setUniformf(`gomax${e}`,1),a.setUniformf(`goscale${e}`,0),a.setUniformf(`goshift${e}`,1)}else{const e=i.scale[l-1],t=s.getGradientOpacityMinimumOpacity(0),n=s.getGradientOpacityMaximumOpacity(0);a.setUniformf("gomin0",t),a.setUniformf("gomax0",n);const r=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];a.setUniformf("goscale0",e*(n-t)/(r[1]-r[0])),a.setUniformf("goshift0",-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===e.isLabelmapOutlineRequired(o)){const e=o.getProperty().getLabelOutlineOpacity();a.setUniformf("outlineOpacity",e)}t.lightComplexity>0&&(a.setUniformf("vAmbient",s.getAmbient()),a.setUniformf("vDiffuse",s.getDiffuse()),a.setUniformf("vSpecular",s.getSpecular()),a.setUniformf("vSpecularPower",s.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*En(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Fg.NEAREST?(t.scalarTexture.setMinificationFilter(Rd.NEAREST),t.scalarTexture.setMagnificationFilter(Rd.NEAREST)):(t.scalarTexture.setMinificationFilter(Rd.LINEAR),t.scalarTexture.setMagnificationFilter(Rd.LINEAR)),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):jg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.scalarTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(Rd.LINEAR),t.jitterTexture.setMagnificationFilter(Rd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,Cs.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=e.useIndependentComponents(i),c=l?s:1,u=i.getScalarOpacity(),d=t._openGLRenderWindow.getGraphicsResourceForObject(u);let p=cg(u,l,c);if(d?.oglObject&&d.hash===p)t.opacityTexture=d.oglObject;else{t.opacityTexture=Kd.newInstance(),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const r=1024,o=2*r*c,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<c;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(Rd.LINEAR),t.opacityTexture.setMagnificationFilter(Rd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.FLOAT,a);else{const e=new Uint8ClampedArray(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.UNSIGNED_CHAR,e)}u&&(t._openGLRenderWindow.setGraphicsResourceForObject(u,t.opacityTexture,p),u!==t._scalarOpacityFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(u,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalarOpacityFunc,e)),t._scalarOpacityFunc=u)}const f=i.getRGBTransferFunction();p=cg(f,l,c);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===p)t.colorTexture=g.oglObject;else{t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(2*n*c*3),o=new Float32Array(3*n);for(let e=0;e<c;++e){const t=i.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.create2DFromRaw(n,2*c,3,Cs.UNSIGNED_CHAR,r),f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,p),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}e.updateLabelOutlineThicknessTexture(r);const m=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(p=ug(o,a),m?.oglObject?.getHandle()&&m?.hash===p)t.scalarTexture=m.oglObject;else{t.scalarTexture=Kd.newInstance(),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a,t.renderable.getPreferSizeOverAccuracy()),a&&(t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,p),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ns.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ns.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThickness(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{t.labelOutlineThicknessTexture=Kd.newInstance(),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.isLabelmapOutlineRequired=e=>{const n=e.getProperty(),r=t.renderable;return n.getUseLabelOutline()||r.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND}}const $g={context:null,VBOBuildTime:null,scalarTexture:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$g,n),Zt.extend(e,t,n),Yd(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),t.jitterTexture=Kd.newInstance(),t.jitterTexture.setWrapS(Od.REPEAT),t.jitterTexture.setWrapT(Od.REPEAT),t.framebuffer=ef.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,["context"]),Kg(e,t)}),"vtkOpenGLVolumeMapper");rn("vtkVolumeMapper",qg);const{vtkDebugMacro:Xg}=Kt;function Yg(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Xg("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const Zg={};const Qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zg,n),Zt.extend(e,t,n),Yg(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");rn("vtkPixelSpaceCallbackMapper",Qg);var Jg="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:em}=ms;function tm(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Kd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,"Float32Array",null),s.activate(),s.sendParameters(),s.deactivate(),s}function nm(e,t){return tm(e,t,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE)}function rm(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",em.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=nm(t._openGLRenderWindow,t.size),t.seedTexture0=nm(t._openGLRenderWindow,t.size),t.licTexture1=nm(t._openGLRenderWindow,t.size),t.seedTexture1=nm(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?tm(t._openGLRenderWindow,t.size,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return tm(e,t,Kd.Filter.LINEAR,Kd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager")}const om={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function am(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,om,n),jt.obj(e,t),jt.get(e,t,["readIndex"]),jt.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),rm(e,t)}var im={newInstance:jt.newInstance(am,"vtkLICPingPongBufferManager"),extend:am};const sm=0,lm=1,cm=2,um=3,dm=1;function pm(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=ef.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){const e="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    ",t="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ";return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=ef.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=im.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],y=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;y.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:T}=t;y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",0),T.setUniformf("uMaskThreshold",t.maskThreshold),T.setUniform2f("uNoiseBoundsPt1",...m),T.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),T.setUniformi("texLIC",t.bufs.getLICTextureUnit()),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,T);const{LICIShaderProgram:b}=t;y.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",1),n(T,t.bufs),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;y.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)y.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),y.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}const fm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fm,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),pm(e,t)}var mm={newInstance:jt.newInstance(gm,"vtkLineIntegralConvolution2D"),extend:gm};function hm(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}const vm={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:sm,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:dm,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vm,n),jt.obj(e,t),jt.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),hm(0,t)}var Tm={newInstance:jt.newInstance(ym,"vtkSurfaceLICInterface"),extend:ym};const{Representation:bm}=ms;function xm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===dm?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Kd.newInstance({wrapS:Kd.Wrap.REPEAT,wrapT:Kd.Wrap.REPEAT,minificationFilter:Kd.Filter.NEAREST,magnificationFilter:Kd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,"Float32Array",d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.allocateTextures=()=>{const n=Kd.Filter.NEAREST,r=Kd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Kd.newInstance({wrapS:Kd.Wrap.CLAMP_TO_EDGE,wrapT:Kd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,"Float32Array",null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Kd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,"Float32Array",null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=ef.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",bm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=mm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===cm||u===um){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const Cm={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function Sm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cm,n),Tm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),xm(e,t)}var Am={newInstance:jt.newInstance(Sm,"vtkSurfaceLICInterface"),extend:Sm};const{vtkErrorMacro:Im}=Kt;function wm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=yd.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=yd.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=yd.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=yd.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=yd.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(Im("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(Im("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(Im("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Tm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=Am.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(Im("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const Pm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const Om=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pm,n),pp.extend(e,t,n),wm(e,t),At(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");rn("vtkSurfaceLICMapper",Om);const{vtkErrorMacro:Rm}=Kt;function Mm(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||Rm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())o.setUniformMatrix("MCVCMatrix",i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",n)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,Zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Em={};const Dm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Em,n),pp.extend(e,t,n),Mm(e,t)}),"vtkOpenGLSphereMapper");rn("vtkSphereMapper",Dm);const{vtkErrorMacro:Vm}=Kt;function Lm(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=yd.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||Vm("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||Vm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||Vm("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():Vm(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,Zu.ARRAY_BUFFER),a.getColorBO().upload(g,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Bm={};const Nm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bm,n),pp.extend(e,t,n),Lm(e,t)}),"vtkOpenGLStickMapper");rn("vtkStickMapper",Nm);const _m=[];_m["-".charCodeAt(0)]=62,_m["_".charCodeAt(0)]=63;const Fm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<Fm.length;e++)_m[Fm.charCodeAt(e)]=e;function km(e){return void 0!==_m[e.charCodeAt(0)]}function Gm(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<18;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<12;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<6;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<10;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<4;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<2;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function Um(e,t,n){const r=(e<<16)+(t<<8)+n;return Fm[r>>18]+Fm[r>>12&63]+Fm[r>>6&63]+Fm[63&r]}function zm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Um(t[n],t[n+1],t[n+2])}if(n>0){const e=Um(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var Wm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)km(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Gm(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Hm={};function jm(e,t){Hm[e]=t}var Km=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Hm[e](t)},$m=Uint8Array,qm=Uint16Array,Xm=Uint32Array,Ym=new $m([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Zm=new $m([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Qm=new $m([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Jm=function(e,t){for(var n=new qm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Xm(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},eh=Jm(Ym,2),th=eh[0],nh=eh[1];th[28]=258,nh[258]=28;for(var rh=Jm(Zm,0),oh=rh[0],ah=(rh[1],new qm(32768)),ih=0;ih<32768;++ih){var sh=(43690&ih)>>>1|(21845&ih)<<1;sh=(61680&(sh=(52428&sh)>>>2|(13107&sh)<<2))>>>4|(3855&sh)<<4,ah[ih]=((65280&sh)>>>8|(255&sh)<<8)>>>1}var lh=function(e,t,n){for(var r=e.length,o=0,a=new qm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new qm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new qm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[ah[d]>>>l]=c}else for(i=new qm(r),o=0;o<r;++o)e[o]&&(i[o]=ah[s[e[o]-1]++]>>>15-e[o]);return i},ch=new $m(288);for(ih=0;ih<144;++ih)ch[ih]=8;for(ih=144;ih<256;++ih)ch[ih]=9;for(ih=256;ih<280;++ih)ch[ih]=7;for(ih=280;ih<288;++ih)ch[ih]=8;var uh=new $m(32);for(ih=0;ih<32;++ih)uh[ih]=5;var dh=lh(ch,9,1),ph=lh(uh,5,1),fh=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},gh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},mh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},hh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?qm:4==e.BYTES_PER_ELEMENT?Xm:$m)(n-t);return r.set(e.subarray(t,n)),r},vh=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],yh=function(e,t,n){var r=new Error(t||vh[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,yh),!n)throw r;return r},Th=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new $m(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new $m(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new $m(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=gh(e,c,1);var h=gh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&yh(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=dh,p=ph,f=9,g=5;else if(2==h){var T=gh(e,c,31)+257,b=gh(e,c+10,15)+4,x=T+gh(e,c+5,31)+1;c+=14;for(var C=new $m(x),S=new $m(19),A=0;A<b;++A)S[Qm[A]]=gh(e,c+3*A,7);c+=3*b;var I=fh(S),w=(1<<I)-1,P=lh(S,I,1);for(A=0;A<x;){var O,R=P[gh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,E=0;for(16==O?(E=3+gh(e,c,3),c+=2,M=C[A-1]):17==O?(E=3+gh(e,c,7),c+=3):18==O&&(E=11+gh(e,c,127),c+=7);E--;)C[A++]=M}}var D=C.subarray(0,T),V=C.subarray(T);f=fh(D),g=fh(V),d=lh(D,f,1),p=lh(V,g,1)}else yh(1);if(c>m){a&&yh(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[mh(e,c)&L])>>>4;if((c+=15&M)>m){a&&yh(0);break}if(M||yh(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Ym[A=_-257];F=gh(e,c,(1<<k)-1)+th[A],c+=k}var G=p[mh(e,c)&B],U=G>>>4;if(G||yh(3),c+=15&G,V=oh[U],U>3&&(k=Zm[U],V+=mh(e,c)&(1<<k)-1,c+=k),c>m){a&&yh(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:hh(t,0,u)},bh=new $m(0),xh=function(e,t){return e[t]|e[t+1]<<8},Ch=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Sh=function(e,t){return Ch(e,t)+4294967296*Ch(e,t+4)};function Ah(e,t){return Th(e,t)}function Ih(e,t){return Th(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||yh(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new $m((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function wh(e,t){return Th(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&yh(6,"invalid zlib data"),32&n[1]&&yh(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function Ph(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Ih(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Ah(e,t):wh(e,t)}var Oh="undefined"!=typeof TextEncoder&&new TextEncoder,Rh="undefined"!=typeof TextDecoder&&new TextDecoder;try{Rh.decode(bh,{stream:!0})}catch(e){}function Mh(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Rh)return Rh.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,hh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&yh(8),a}var Eh=function(e,t){return t+30+xh(e,t+26)+xh(e,t+28)},Dh=function(e,t,n){var r=xh(e,t+28),o=Mh(e.subarray(t+46,t+46+r),!(2048&xh(e,t+8))),a=t+46+r,i=Ch(e,t+20),s=n&&4294967295==i?Vh(e,a):[i,Ch(e,t+24),Ch(e,t+42)],l=s[0],c=s[1],u=s[2];return[xh(e,t+10),l,c,o,a+xh(e,t+30)+xh(e,t+32),u]},Vh=function(e,t){for(;1!=xh(e,t);t+=4+xh(e,t+2));return[Sh(e,t+12),Sh(e,t+4),Sh(e,t+20)]};function Lh(e,t){for(var n={},r=e.length-22;101010256!=Ch(e,r);--r)(!r||e.length-r>65558)&&yh(13);var o=xh(e,r+8);if(!o)return{};var a=Ch(e,r+16),i=4294967295==a;i&&(r=Ch(e,r-12),101075792!=Ch(e,r)&&yh(13),o=Ch(e,r+32),a=Ch(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=Dh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Eh(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Ah(e.subarray(h,h+d),new $m(p)):yh(14,"unknown compression type "+u):n[f]=hh(e,h,h+d))}return n}function Bh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Nh=Bh(),_h=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:Fh,vtkDebugMacro:kh}=jt;let Gh=0;function Uh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const zh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=Uh("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(kh(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Fh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(Mh(Ph(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(Mh(Ph(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Uh("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(Ph(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};jm("http",(e=>zh));const{vtkDebugMacro:Wh}=jt;function Hh(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Wh("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Wh("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Hi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Hi(o,[...t.position,1],n),Hi(a,[...t.focalPoint,1],n),Hi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=qi(e[0],e[1],e[2],e[3]),n=ji(),r=qi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],$i(r,t,r),$i(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=ji();Ki(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const jh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Kh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jh,n),jt.obj(e,t),jt.get(e,t,["distance"]),jt.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),jt.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),jt.setGetArray(e,t,["clippingRange","windowCenter"],2),jt.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),Hh(e,t)}var $h={newInstance:jt.newInstance(Kh,"vtkCamera"),extend:Kh};function qh(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}const Xh={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Yh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xh,n),jt.obj(e,t),jt.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),jt.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),qh(e,t)}var Zh={newInstance:jt.newInstance(Yh,"vtkLight"),extend:Yh,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Qh}=jt;function Jh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Qh("call displayToView on your view instead"),e.viewToDisplay=()=>Qh("callviewtodisplay on your view instead"),e.getSize=()=>Qh("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=("PickPropFrom",()=>Qh("vtkViewport::PickPropFrom - NOT IMPLEMENTED"))}const ev={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function tv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ev,n),jt.obj(e,t),jt.event(e,t,"event"),jt.setGetArray(e,t,["viewport"],4),jt.setGetArray(e,t,["background","background2"],3),Jh(e,t)}var nv={newInstance:jt.newInstance(tv,"vtkViewport"),extend:tv};const{vtkDebugMacro:rv,vtkErrorMacro:ov,vtkWarningMacro:av}=Kt;function iv(e){return()=>ov(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function sv(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(rv("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):ov("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=iv("allocateTime"),e.updateGeometry=iv("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{rv(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=$h.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Zh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return ov("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return ov("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Wi.INIT_BOUNDS[0],t.allBounds[1]=Wi.INIT_BOUNDS[1],t.allBounds[2]=Wi.INIT_BOUNDS[2],t.allBounds[3]=Wi.INIT_BOUNDS[3],t.allBounds[4]=Wi.INIT_BOUNDS[4],t.allBounds[5]=Wi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),rv("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return rv("Cannot reset camera!"),!1;let i=null;if(!e.getActiveCamera())return ov("Trying to reset non-existent camera"),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&(av("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return rv("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return ov("Trying to reset clipping range of non-existent camera"),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const lv={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,lv,n),nv.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),At(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),It(e,t,["actors","volumes","lights"]),Pt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),sv(e,t)}var uv={newInstance:Dt(cv,"vtkRenderer"),extend:cv};const dv=Object.create(null);function pv(e,t){dv[e]=t}function fv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dv[e]&&dv[e](t)}function gv(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return fv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}const mv={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mv,n),jt.obj(e,t),jt.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),jt.get(e,t,["neverRendered"]),jt.getArray(e,t,["renderers","childRenderWindows"]),jt.moveToProtected(e,t,["views"]),jt.event(e,t,"completion"),gv(e,t)}var vv={newInstance:jt.newInstance(hv,"vtkRenderWindow"),extend:hv,registerViewConstructor:pv,listViewAPIs:function(){return Object.keys(dv)},newAPISpecificView:fv};const yv={Unknown:0,LeftController:1,RightController:2},Tv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var bv={Device:yv,Input:Tv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:xv,Input:Cv}=bv,{vtkWarningMacro:Sv,vtkErrorMacro:Av,normalizeWheel:Iv,vtkOnceErrorMacro:wv}=jt,Pv={ctrlKey:!1,altKey:!1,shiftKey:!1},Ov={"xr-standard":[Cv.Trigger,Cv.Grip,Cv.TrackPad,Cv.Thumbstick,Cv.A,Cv.B]},Rv=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Mv(e){e.cancelable&&e.preventDefault()}function Ev(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function Dv(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Av("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Sv("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Mv),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),document.addEventListener("keypress",e.handleKeyPress),document.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Mv),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),document.removeEventListener("keypress",e.handleKeyPress),document.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Mv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Sv("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Mv(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Av(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Sv("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Av("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Sv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?xv.LeftController:xv.RightController,input:Ov[s.mapping]&&Ov[s.mapping][r]?Ov[s.mapping][r]:Cv.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?xv.LeftController:xv.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Mv(n);const r={...Iv(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Av(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);if(2===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Ev(o);e.recognizeGesture("TouchEnd",t);const a={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Rv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void wv("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}const Vv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,"RenderEvent"),Rv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),jt.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),jt.moveToProtected(e,t,["view"]),Dv(e,t)}var Bv={newInstance:jt.newInstance(Lv,"vtkRenderWindowInteractor"),extend:Lv,handledEvents:Rv,...bv};const{vtkErrorMacro:Nv,VOID:_v}=jt;function Fv(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Bv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):_v),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Nv("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const kv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),jt.obj(e,t),jt.event(e,t,"InteractionEvent"),jt.event(e,t,"StartInteractionEvent"),jt.event(e,t,"EndInteractionEvent"),jt.get(e,t,["_interactor","enabled"]),jt.setGet(e,t,["priority","processEvents"]),jt.moveToProtected(e,t,["interactor"]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,"vtkInteractorObserver"),extend:Gv,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},zv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Wv}=zv,Hv={Rotate:Wv.IS_ROTATE,Pan:Wv.IS_PAN,Spin:Wv.IS_SPIN,Dolly:Wv.IS_DOLLY,CameraPose:Wv.IS_CAMERA_POSE,WindowLevel:Wv.IS_WINDOW_LEVEL,Slice:Wv.IS_SLICE};function jv(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(Hv).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Wv.IS_NONE&&(t.state=Hv[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Hv[n]&&(t.state=Wv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Kv={state:Wv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Uv.extend(e,t,n),jt.setGet(e,t,["focusedRenderer"]),jv(e,t)}var qv={newInstance:jt.newInstance($v,"vtkInteractorStyle"),extend:$v,...zv};const{States:Xv}=zv;function Yv(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case Xv.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad?!n||n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad||t.state!==Xv.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===Xv.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case Xv.IS_DOLLY:e.endDolly();break;case Xv.IS_PAN:e.endPan();break;case Xv.IS_SPIN:e.endSpin();break;case Xv.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const Zv={motionFactor:10,zoomFactor:10};function Qv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zv,n),qv.extend(e,t,n),jt.setGet(e,t,["motionFactor","zoomFactor"]),Yv(e,t)}var Jv={newInstance:jt.newInstance(Qv,"vtkInteractorStyleTrackballCamera"),extend:Qv};function ey(e){return e}function ty(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>ty(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var ny=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?ty:ey,o=new URLSearchParams(t);return o.forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};function ry(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const oy={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),jt.obj(e,t),jt.get(e,t,["currentOperation"]),jt.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),jt.moveToProtected(e,t,["currentParent"]),ry(e,t)}var iy={newInstance:jt.newInstance(ay,"vtkRenderPass"),extend:ay};const{Representation:sy}=ms,{vtkErrorMacro:ly}=jt;function cy(e){const t=yd.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}function uy(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ns.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ns.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",sy.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Kd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,"Float32Array",null),t.translucentRTexture=Kd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,"Float32Array",null),t.translucentZTexture=Kd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],"Float32Array",null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||ly("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||ly("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?cy:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const dy={framebuffer:null,copyShader:null,tris:null};function py(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dy,n),iy.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),jt.get(e,t,["framebuffer"]),uy(e,t)}var fy={newInstance:jt.newInstance(py,"vtkOpenGLOrderIndependentTranslucentPass"),extend:py};function gy(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=ef.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=fy.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const my={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),iy.extend(e,t,n),jt.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,"vtkForwardPass"),extend:hy},yy=n(594),Ty=n.n(yy);const by=["lastShaderProgramBound","context","_openGLRenderWindow"];function xy(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=yd.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=yd.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=yd.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=yd.substitute(l,"varying","out").result,o=yd.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=yd.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=yd.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:yd.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Ty().hash(o);if(!(a in t.shaderPrograms)){const o=yd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const Cy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,by),jt.moveToProtected(e,t,["openGLRenderWindow"]),xy(e,t)}var Ay={newInstance:jt.newInstance(Sy,"vtkShaderCache"),extend:Sy};const{vtkErrorMacro:Iy}=jt;function wy(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&Iy("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const Py={context:null,numberOfTextureUnits:0,textureUnits:0};function Oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Py,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,["numberOfTextureUnits"]),jt.setGet(e,t,["context"]),wy(e,t)}var Ry={newInstance:jt.newInstance(Oy,"vtkOpenGLTextureUnitManager"),extend:Oy};function My(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro("not implemented")},e.createSelector=()=>{jt.vtkErrorMacro("not implemented")}}const Ey={size:void 0,selector:void 0};function Dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),t.size||(t.size=[300,300]),jt.getArray(e,t,["size"],2),jt.get(e,t,["selector"]),Zt.extend(e,t,n),My(e,t)}var Vy={newInstance:jt.newInstance(Dy,"vtkRenderWindowViewNode"),extend:Dy};const{vtkDebugMacro:Ly,vtkErrorMacro:By}=jt,Ny={position:"absolute",top:0,left:0,width:"100%",height:"100%"},_y=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Fy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let ky=0;const Gy=[];function Uy(e){e.preventDefault()}function zy(e,t){let n;function r(){return n||(n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n}t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",Uy,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const o=[0,0];let a;e.onModified((function(){t.renderable&&(t.size[0]===o[0]&&t.size[1]===o[1]||(o[0]=t.size[0],o[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(ky++,Gy.forEach((e=>e(ky)))),t.textureUnitManager=Ry.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&By("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},n=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(n=t.canvas.getContext("webgl2",e),n&&(t.webgl2=!0,Ly("using webgl2"))),n||(Ly("using webgl1"),n=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(n,r())},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=iy.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?By("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case Cs.CHAR:case Cs.SIGNED_CHAR:case Cs.UNSIGNED_CHAR:return 1;case n:case r:case Cs.UNSIGNED_SHORT:case Cs.SHORT:case Cs.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case Cs.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&Cs.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&Cs.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Ny,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=a)return a;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return a=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Fy(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Fy(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Fy(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Fy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Fy(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Fy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Fy(n,n.RGB,n.FLOAT)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=xf.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((()=>{t.context&&(ky--,Gy.forEach((e=>e(ky)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",Uy),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const i=e.setSize;e.setSize=(t,n)=>{const r=i(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null),t._graphicsResources.get(n)?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))};const s={...e};_y.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):s[n](...arguments)}}))}const Wy={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const Hy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),Vy.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=xf.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.shaderCache=Ay.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=vy.newInstance(),jt.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),jt.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"imageReady"),jt.event(e,t,"windowResizeEvent"),zy(e,t)}),"vtkOpenGLRenderWindow");function jy(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}pv("WebGL",Hy),rn("vtkRenderWindow",Hy);const Ky={device:null,handle:null};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["device","handle"]),jy(e,t)}var qy={newInstance:jt.newInstance($y,"vtkWebGPUShaderModule"),extend:$y};function Xy(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=qy.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const Yy={shaderModules:null,device:null,window:null};function Zy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yy,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,["device","window"]),Xy(e,t)}var Qy={newInstance:jt.newInstance(Zy,"vtkWebGPUShaderCache"),extend:Zy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function Jy(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}const eT={device:null,handle:null,label:null};function tT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eT,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),jt.setGet(e,t,["label","device","arrayInformation"]),Jy(e,t)}var nT={newInstance:jt.newInstance(tT),extend:tT};function rT(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const oT={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function aT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oT,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,["handle","pipelineDescription"]),At(e,t,["device","renderEncoder","topology","vertexState"]),rT(e,t)}var iT={newInstance:Dt(aT,"vtkWebGPUPipeline"),extend:aT};function sT(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Qy.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=Qy.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=Qy.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}const lT={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lT,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,["type","hash","code"]),jt.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),sT(e,t)}var uT={newInstance:jt.newInstance(cT,"vtkWebGPUShaderDescription"),extend:cT};const dT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var pT=function(e){return!e||e.length<6?0:e in dT==1?dT[e]:(et(`unknown format ${e}`),null)},fT=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},gT=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void et(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;et(`unknown format ${e}`)},mT=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void et(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},hT=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},vT=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void et(`unknown format ${e}`)};function yT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function TT(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(yT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=mT(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const bT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function xT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,["created","device","handle","indexBuffer"]),TT(e,t)}var CT={newInstance:Dt(xT,"vtkWebGPUVertexInput"),extend:xT};const ST="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",AT="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function IT(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=uT.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=uT.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=iT.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const wT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=CT.newInstance(),t.bindGroup=nT.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||AT,t.vertexShaderTemplate=t.vertexShaderTemplate||ST,t.shaderReplacements=new Map,jt.get(e,t,["pipeline","vertexInput"]),jt.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),IT(e,t)}var OT={newInstance:jt.newInstance(PT,"vtkWebGPUSimpleMapper"),extend:PT};function RT(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}const MT={};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),OT.extend(e,t,n),RT(e,t)}var DT={newInstance:jt.newInstance(ET,"vtkWebGPUFullScreenQuad"),extend:ET};const VT=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"];function LT(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<VT.length;n++)e[VT[n]]=function(){return t.handle[VT[n]](...arguments)}}const BT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],bt(e,t,["boundPipeline","colorTextureViews"]),At(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),LT(e,t)}var _T={newInstance:Dt(NT,"vtkWebGPURenderEncoder"),extend:NT},FT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const kT=["getMappedRange","mapAsync","unmap"];function GT(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<kT.length;n++)e[kT[n]]=function(){return t.handle[kT[n]](...arguments)}}const UT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function zT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,UT,n),jt.obj(e,t),jt.get(e,t,["handle","sizeInBytes","usage"]),jt.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),GT(e,t)}var WT={newInstance:jt.newInstance(zT),extend:zT,...FT};const{Representation:HT}=ms,{PrimitiveTypes:jT}=FT;class KT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function $T(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function qT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=$T(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=$T(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=$T(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=$T(n,o,t),n.ibo[n.iboId++]=a}function XT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let YT;const ZT=new Uint32Array(1),QT=new Uint32Array(2),JT=new Uint32Array(3),eb={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)ZT[0]=t[n+a],YT(ZT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)QT[0]=t[n+a],QT[1]=t[n+(a+1)%e],YT(QT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o);for(let a=0;a<e-2;a++)QT[0]=t[n+a],QT[1]=t[n+a+2],YT(QT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n],JT[1]=t[n+a+1],JT[2]=t[n+a+2],YT(JT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n+a],JT[1]=t[n+a+1+a%2],JT[2]=t[n+a+1+(a+1)%2],YT(JT,r,o)}};function tb(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case jT.Points:return"points";case jT.Lines:return"lines";case jT.Triangles:case jT.TriangleEdges:return"polys";case jT.TriangleStripEdges:case jT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new KT};let d=null;d=o===HT.POINTS||r===jT.Points?eb.anythingToPoints:o===HT.WIREFRAME||r===jT.Lines?eb[`${l}ToWireframe`]:eb[`${l}ToSurface`],YT=XT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),YT=qT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const nb={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nb,n),WT.extend(e,t,n),jt.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),tb(e,t)}var ob={newInstance:jt.newInstance(rb),extend:rb,...FT};const{BufferUsage:ab}=FT,{vtkErrorMacro:ib}=Kt,{VtkDataTypes:sb}=Ns;function lb(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function cb(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function ub(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===ab.Index&&(n=ob.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=WT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===ab.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===ab.PointArray){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=lb(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===ab.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=cb(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=lb(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===ab.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case sb.UNSIGNED_CHAR:t="uint8";break;case sb.FLOAT:t="float32";break;case sb.UNSIGNED_INT:t="uint32";break;case sb.INT:t="sint32";break;case sb.DOUBLE:t="float32";break;case sb.UNSIGNED_SHORT:t="uint16";break;case sb.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||ib(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:ab.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=WT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}const db={device:null,fullScreenQuadBuffer:null};function pb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,db,n),yt(e,t),At(e,t,["device"]),ub(e,t)}var fb={newInstance:Dt(pb),extend:pb,...FT};function gb(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const mb={device:null,handle:null,label:null,options:null};function hb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mb,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","options"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label"]),gb(e,t)}var vb={newInstance:jt.newInstance(hb),extend:hb};function yb(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=vb.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const Tb={texture:null,handle:null,sampler:null,label:null};function bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","texture"]),jt.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),yb(e,t)}var xb={newInstance:jt.newInstance(bb),extend:bb};const{BufferUsage:Cb}=fb;function Sb(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,n.nativeArray=n.jsImageData.data);const o=pT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&"float"===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?"Uint16Array":i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Vd.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement("canvas");e.width=n.image.width,e.height=n.image.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Pu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:Cb.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:Cb.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=pT(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>pT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=xb.newInstance({label:n});return o.create(e,r),o}}const Ab={device:null,handle:null,buffer:null,ready:!1,label:null};function Ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ab,n),jt.obj(e,t),jt.get(e,t,["handle","ready","width","height","depth","format","usage"]),jt.setGet(e,t,["device","label"]),Sb(e,t)}var wb={newInstance:jt.newInstance(Ib),extend:Ib};function Pb(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=wb.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=_T.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}const Ob={renderEncoder:null,colorTexture:null,depthTexture:null};function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ob,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Pb(e,t)}var Mb={newInstance:jt.newInstance(Rb,"vtkWebGPUOpaquePass"),extend:Rb};function Eb(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=wb.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=wb.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=DT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=_T.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcfactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=_T.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}const Db={colorTextureView:null,depthTextureView:null};function Vb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Db,n),iy.extend(e,t,n),jt.setGet(e,t,["colorTextureView","depthTextureView"]),Eb(e,t)}var Lb={newInstance:jt.newInstance(Vb,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Vb};const{BufferUsage:Bb}=fb,{vtkErrorMacro:Nb}=jt;function _b(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Nb(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:hT(n),offset:-1,nativeType:vT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Bb.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}const Fb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,["binding","bindGroupTime"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),_b(e,t)}var Gb={newInstance:jt.newInstance(kb,"vtkWebGPUUniformBuffer"),extend:kb};const{BufferUsage:Ub}=fb,{vtkErrorMacro:zb}=jt;function Wb(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void zb(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=hT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:vT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Ub.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Hb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function jb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},jt.get(e,t,["bindGroupTime"]),jt.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),Wb(e,t)}var Kb={newInstance:jt.newInstance(jb,"vtkWebGPUStorageBuffer"),extend:jb};const $b="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",qb=new Float64Array(16),Xb=new Float64Array(16);function Yb(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===zg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=Qy.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=Qy.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=Qy.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===zg.COMPOSITE_BLEND?l=!0:n===zg.MAXIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.MINIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.AVERAGE_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.ADDITIVE_INTENSITY_BLEND&&(a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=Qy.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(qb),b(qb,qb,o);const p=n.getMatrix();m(Xb,p),h(Xb,Xb),T(qb,Xb,qb);const f=d.getWorldToIndex();T(qb,f,qb);const v=d.getDimensions();g(Xb),x(Xb,Xb,[1/v[0],1/v[1],1/v[2]]),T(qb,Xb,qb);for(let t=0;t<16;t++)a[16*e+t]=qb[t];h(qb,qb);for(let t=0;t<4;t++)i[16*e+4*t]=qb[4*t],i[16*e+4*t+1]=qb[4*t+1],i[16*e+4*t+2]=qb[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=pT(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",y),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=vb.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Zb={volumes:null,rowLength:1024,lastVolumeLength:0};function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zb,n),DT.extend(e,t,n),t.fragmentShaderTemplate=$b,t.UBO=Gb.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=Kb.newInstance({label:"volumeSSBO"}),t.componentSSBO=Kb.newInstance({label:"componentSSBO"}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),Yb(e,t)}var Jb={newInstance:jt.newInstance(Qb,"vtkWebGPUVolumePassFSQ"),extend:Qb};const{Representation:ex}=ms,{BufferUsage:tx,PrimitiveTypes:nx}=fb,rx=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],ox="\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function ax(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=Jb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=DT.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=Gb.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:tx.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:nx.Triangles,representation:ex.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:tx.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+rx[e][0],l[n++]=r+rx[e][1],l[n++]=r+rx[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=_T.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcfactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcfactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=wb.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=wb.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=wb.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=_T.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=_T.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=_T.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const ix={colorTextureView:null,depthTextureView:null,volumes:null};function sx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ix,n),iy.extend(e,t,n),t._mapper=OT.newInstance(),t._mapper.setFragmentShaderTemplate(ox),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Cu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,["colorTextureView","depthTextureView"]),ax(e,t)}var lx={newInstance:jt.newInstance(sx,"vtkWebGPUVolumePass"),extend:sx};function cx(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Mb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Lb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=lx.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=_T.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=vb.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=DT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=xb.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const ux={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ux,n),iy.extend(e,t,n),jt.setGet(e,t,["opaquePass","translucentPass","volumePass"]),cx(e,t)}var px={newInstance:jt.newInstance(dx,"vtkForwardPass"),extend:dx};const{VtkDataTypes:fx}=Ns;function gx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case fx.UNSIGNED_CHAR:e.format+="8unorm";break;case fx.FLOAT:case fx.UNSIGNED_INT:case fx.INT:case fx.DOUBLE:case fx.UNSIGNED_SHORT:case fx.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm"),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=wb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const mx={handle:null,device:null};function hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mx,n),jt.obj(e,t),jt.setGet(e,t,["device"]),gx(e,t)}var vx={newInstance:jt.newInstance(hx),extend:hx};class yx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function Tx(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const bx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bx,n),yt(e,t),At(e,t,["handle"]),bt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new yx,t.shaderCache=Qy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=fb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=vx.newInstance(),t.textureManager.setDevice(e),t.pipelines={},Tx(e,t)}var Cx={newInstance:Dt(xx,"vtkWebGPUDevice"),extend:xx};function Sx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=wb.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=_T.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}const Ax={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,"vtkWebGPUHardwareSelectionPass"),extend:Ix};const{SelectionContent:Px,SelectionField:Ox}=of,{FieldAssociations:Rx}=ll,{vtkErrorMacro:Mx}=jt;function Ex(e){return`${e.propID} ${e.compositeID}`}function Dx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Vx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=Dx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=Dx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Vx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Vx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Vx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Vx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Vx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Lx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Mx("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=WT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=WT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Vx(e,[n,t],0,u);if(r){const t=Ex(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=of.newInstance();switch(i.setContentType(Px.INDICES),e){case Rx.FIELD_ASSOCIATION_CELLS:i.setFieldType(Ox.CELL);break;case Rx.FIELD_ASSOCIATION_POINTS:i.setFieldType(Ox.POINT);break;default:Mx("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Bx={};function Nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),Yp.extend(e,t,n),t._selectionPass=wx.newInstance(),jt.setGet(e,t,["_WebGPURenderWindow"]),jt.moveToProtected(e,t,["WebGPURenderWindow"]),Lx(e,t)}var _x={newInstance:jt.newInstance(Nx,"vtkWebGPUHardwareSelector"),extend:Nx};const Fx=Object.create(null);function kx(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}const Gx={};function Ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gx,n),t.overrides=Fx,tn.extend(e,t,n),kx(0,t)}var zx={newInstance:jt.newInstance(Ux,"vtkWebGPUViewNodeFactory"),extend:Ux};const{vtkErrorMacro:Wx}=jt,Hx={position:"absolute",top:0,left:0,width:"100%",height:"100%"};function jx(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Wx("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Wx("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=Cx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=iy.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Hx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=WT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Vd.fromHalf(r.colorValues[o]),s[n+1]=255*Vd.fromHalf(r.colorValues[o+1]),s[n+2]=255*Vd.fromHalf(r.colorValues[o+2]),s[n+3]=255*Vd.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=_x.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Kx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const $x=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kx,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Vy.extend(e,t,n),t.myFactory=zx.newInstance(),t.renderPasses[0]=px.newInstance(),t.selector||(t.selector=_x.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,"imageReady"),jt.event(e,t,"initialized"),jt.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),jt.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"windowResizeEvent"),jx(e,t)}),"vtkWebGPURenderWindow");var qx;pv("WebGPU",$x),qx=$x,Fx.vtkRenderWindow=qx;const Xx=ny(),Yx={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Zx={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Qx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Jx(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Qx(t.container,t.containerStyle||Yx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=vv.newInstance(),t.renderer=uv.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Xx.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Bv.newInstance(),t.interactor.setInteractorStyle(Jv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Qx(t.controlContainer,t.controlPanelStyle||Zx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}const eC={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function tC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eC,n),jt.obj(e,t),jt.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),Jx(e,t)}var nC={newInstance:jt.newInstance(tC),extend:tC},rC={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:oC,Scale:aC}=rC,{ScalarMappingTarget:iC}=El,{vtkDebugMacro:sC,vtkErrorMacro:lC,vtkWarningMacro:cC}=jt;function uC(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function dC(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function pC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];uC(o,i),uC(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=dC(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=dC(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function fC(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return lC("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return lC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===aC.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Eo(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===oC.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===oC.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===oC.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===oC.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return lC("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(lC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return lC("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void lC("attempt to set zero width color range");const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):sC("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void cC("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===iC.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===iC.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===iC.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===iC.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=oC[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(lC(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=oC.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const gC={clamping:!0,colorSpace:oC.RGB,hSVWrap:!0,scale:aC.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function mC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gC,n),El.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,["buildTime","mappingRange"]),jt.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:oC},{type:"enum",name:"scale",enum:aC}]),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),fC(e,t)}var hC={newInstance:jt.newInstance(mC,"vtkColorTransferFunction"),extend:mC,...rC},vC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:yC,ScaleModes:TC}=vC,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>jt.enumToString(yC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(yC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(yC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(yC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(TC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(TC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(TC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(TC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===TC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(bC("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Wi.getCorners(l,c),t.bounds[0]=Wi.INIT_BOUNDS[0],t.bounds[1]=Wi.INIT_BOUNDS[1],t.bounds[2]=Wi.INIT_BOUNDS[2],t.bounds[3]=Wi.INIT_BOUNDS[3],t.bounds[4]=Wi.INIT_BOUNDS[4],t.bounds[5]=Wi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case yC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case yC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case yC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case TC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case TC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case TC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const CC={orient:!0,orientationMode:yC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:TC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,CC,n),uc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),jt.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,"vtkGlyph3DMapper"),extend:SC,...vC};const{vtkErrorMacro:IC}=jt;function wC(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(IC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return IC("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return IC("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return IC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const PC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,["allowDuplicateScalars","clamping"]),jt.setArray(e,t,["range"],2),jt.getArray(e,t,["range"]),wC(e,t)}var RC={newInstance:jt.newInstance(OC,"vtkPiecewiseFunction"),extend:OC};const{InterpolationType:MC,OpacityMode:EC}=Ug,{vtkErrorMacro:DC}=jt;function VC(e,t){t.classHierarchy.push("vtkVolumeProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(DC("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=RC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=hC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=RC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return DC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(DC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(MC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(MC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(MC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(MC,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const LC={colorMixPreset:null,independentComponents:!0,interpolationType:MC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,LC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:EC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}jt.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),VC(e,t)}var NC={newInstance:jt.newInstance(BC,"vtkVolumeProperty"),extend:BC,...Ug};const{vtkDebugMacro:_C}=jt;function FC(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>e,e.makeProperty=NC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){_C("Recomputing bounds..."),t.mapperBounds=n.map((e=>e));const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const kC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function GC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kC,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper"]),jt.getArray(e,t,["bounds"],6),FC(e,t)}var UC={newInstance:jt.newInstance(GC,"vtkVolume"),extend:GC};const{BlendMode:zC,FilterMode:WC}=Wg,HC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=RC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function jC(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(zC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(zC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(zC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(zC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(zC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(zC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(zC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(WC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(WC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(WC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(WC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Eo(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const KC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:zC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:WC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function $C(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KC,n),zs(e,t,n),jt.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","volumeShadowSamplingDistFactor","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius"]),jt.setGetArray(e,t,["ipScalarRange"],2),jt.event(e,t,"lightingActivated"),jC(e,t)}var qC={newInstance:jt.newInstance($C,"vtkVolumeMapper"),extend:$C,...HC};const{InterpolationType:XC}=pg,{vtkErrorMacro:YC}=jt;function ZC(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return YC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(YC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(XC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(XC.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(XC,t.interpolationType)}const QC={independentComponents:!1,interpolationType:XC.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function JC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,QC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),ZC(e,t)}var eS={newInstance:jt.newInstance(JC,"vtkImageProperty"),extend:JC};const{vtkDebugMacro:tS}=jt;function nS(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=eS.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){tS("Recomputing bounds..."),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Wi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Wi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Wi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const rS={mapper:null,property:null,forceOpaque:!1,forceTranslucent:!1,bounds:[...Wi.INIT_BOUNDS]};function oS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rS,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),jt.getArray(e,t,["bounds"],6),nS(e,t)}var aS={newInstance:jt.newInstance(oS,"vtkImageSlice"),extend:oS};function iS(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Fa())}const sS={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var lS=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sS,n),zs(e,t,n),jt.setGet(e,t,["slice","useCustomExtents"]),jt.setGetArray(e,t,["customDisplayExtent"],6),jt.setGetArray(e,t,["backgroundColor"],4),iS(e,t)};function cS(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ii.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:uS,otherStaticMethods:dS}=Kl,{SlicingMode:pS}=yg;function fS(e,t){function n(){let n;switch(t.slicingMode){case pS.X:n=0;break;case pS.Y:n=1;break;case pS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case pS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case pS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case pS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case pS.I:l=Ma(a[0],i[0],i[1]);break;case pS.J:l=Ma(a[1],i[2],i[3]);break;case pS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case pS.I:case pS.J:case pS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case pS.X:e.setSlice(r[0]);break;case pS.Y:e.setSlice(r[1]);break;case pS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(pS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(pS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(pS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(pS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(pS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(pS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case pS.X:n[0]=1;break;case pS.Y:n[1]=1;break;case pS.Z:n[2]=1;break;case pS.I:ea(r,[1,0,0],n);break;case pS.J:ea(r,[0,1,0],n);break;case pS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==pS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case pS.I:r[0]=a,r[1]=a;break;case pS.J:r[2]=a,r[3]=a;break;case pS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case pS.I:a[0]=s-r,a[1]=s+r;break;case pS.J:a[2]=s-r,a[3]=s+r;break;case pS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const gS={slicingMode:pS.NONE,closestIJKAxis:{ijkMode:pS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function mS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gS,n),lS(e,t,n),jt.get(e,t,["slicingMode"]),jt.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Kl.implementCoincidentTopologyMethods(e,t),fS(e,t)}var hS={newInstance:jt.newInstance(mS,"vtkImageMapper"),extend:mS,...uS,...dS,...yg};const{vtkErrorMacro:vS}=jt;function yS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function TS(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void vS("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Cu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Xs.SINGLE?s=Cs.FLOAT:t.outputPointsPrecision===Xs.DOUBLE&&(s=Cs.DOUBLE);const v=Sc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ns.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ns.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ns.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),yS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),yS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),yS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),yS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const bS={outputPointsPrecision:Xs.DEFAULT};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.setGet(e,t,["outputPointsPrecision"]),jt.obj(e,t),jt.algo(e,t,1,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,"vtkAppendPolyData"),extend:xS};function SS(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Kf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Cu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const AS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function IS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AS,n),jt.obj(e,t),jt.setGet(e,t,["height","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),SS(e,t)}var wS={newInstance:jt.newInstance(IS,"vtkConeSource"),extend:IS};function PS(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ns.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ns.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Kf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Cu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const OS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function RS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OS,n),jt.obj(e,t),jt.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),PS(e,t)}var MS={newInstance:jt.newInstance(RS,"vtkCylinderSource"),extend:RS};function ES(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=MS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();jf().rotateZ(-90).apply(a).apply(i);const s=wS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Kf().translate(1-.5*t.tipLength,0,0).apply(c);const u=CS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Kf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Kf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Kf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const DS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function VS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DS,n),jt.obj(e,t),jt.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),jt.setGetArray(e,t,["direction"],3),jt.algo(e,t,0,1),ES(e,t)}var LS={newInstance:jt.newInstance(VS,"vtkArrowSource"),extend:VS};function BS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];jf().translate(...n).apply(e.getPoints().getData())}function NS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],jf().translate(...o).apply(e.getPoints().getData())}function _S(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ns.newInstance({name:"color",numberOfComponents:3,values:a}))}function FS(e,t){t.classHierarchy.push("vtkAxesActor");const n=uc.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=LS.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?BS(r):NS(r,0,e.invert),_S(r,...e.color),e={...t.config,...t.yConfig};const o=LS.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?BS(o):NS(o,1,e.invert),_S(o,...e.color),e={...t.config,...t.zConfig};const a=LS.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?BS(a):NS(a,2,e.invert),_S(a,...e.color);const i=CS.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=jt.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}function kS(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}function GS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,kS(n)),jt.setGet(e,t,["config","xConfig","yConfig","zConfig"]),FS(e,t)}var US={newInstance:jt.newInstance(GS,"vtkAxesActor"),extend:GS};const zS="resetcamera",WS="orientation",HS={MODE_RESET_CAMERA:zS,MODE_ORIENTATION:WS,MODE_SAME:"same"};function jS(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===WS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===zS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const KS={mode:WS,focalPoint:[0,0,0],distance:6.8,active:!0};function $S(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KS,n),yt(e,t),At(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),Pt(e,t,["focalPoint"],3,0),jS(e,t)}var qS={newInstance:Dt($S,"vtkCameraSynchronizer"),extend:$S,SynchronizationMode:HS};const XS={},YS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=qS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:qS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ZS=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;XS[r]||(XS[r]={});const o=XS[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=qS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];YS[e.type]?o[r]=new YS[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const QS={},JS=/instance:\${([^}]+)}/,eA={},tA=[],nA={},rA={vtkPoints:Sc,vtkCellArray:vc,vtkDataArray:Ns};function oA(e){return e.map((e=>JS.exec(e))).filter((e=>e)).map((e=>e[1]))}function aA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),aA(e,t)})),t}function iA(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=QS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function sA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=QS[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function lA(){Object.keys(QS).forEach((e=>{delete QS[e]}))}function cA(){Object.keys(eA).forEach((e=>{delete eA[e]}))}function uA(e){if(1===e[1].length)return-1===tA.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===tA.indexOf(e[1][n]);return t}function dA(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(nA[r]){const{key:n,value:o}=nA[r];if(!n||e.properties[n]===o)return void tA.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=sA(r,{managedInstanceId:t}),n.registerInstance(t,o)),iA(r,o,e,n)})),t.calls&&t.calls.filter(uA).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=JS.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=rA[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function pA(e,t,n){eA[t.id]||dA(e,t,n),eA[t.id]=!0}function fA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function gA(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function mA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=gA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=gA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),fA(t.getPointData(),i.pointData),fA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=dA(t,s,r);return r.end(),l}}const hA=mA(["points","polys","verts","lines","strips"]),vA=mA([]);function yA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:dA;sA||iA?QS[e]={build:t,update:n}:delete QS[e]}const TA={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},bA={vtkAxesActor:{build:US.newInstance,update:dA},vtkRenderWindow:{build:vv.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(uA).filter((e=>"removeRenderer"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),dA(e,t,n),ZS(e,t,n)}},vtkRenderer:{build:uv.newInstance,update:function(e,t,n){dA(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=aA(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(uA).filter((e=>"removeViewProp"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:Nl.newInstance,update:dA},vtkCamera:{build:$h.newInstance,update:pA},vtkPolyData:{build:Cu.newInstance,update:hA},vtkImageData:{build:vl.newInstance,update:vA},vtkMapper:{build:uc.newInstance,update:dA},vtkGlyph3DMapper:{build:AC.newInstance,update:dA},vtkProperty:{build:ms.newInstance,update:dA},vtkActor:{build:bs.newInstance,update:dA},vtkLight:{build:Zh.newInstance,update:dA},vtkColorTransferFunction:{build:hC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Pu.newInstance,update:dA},vtkVolume:{build:UC.newInstance,update:dA},vtkVolumeMapper:{build:qC.newInstance,update:dA},vtkVolumeProperty:{build:NC.newInstance,update:dA},vtkImageSlice:{build:aS.newInstance,update:dA},vtkImageMapper:{build:hS.newInstance,update:dA},vtkImageProperty:{build:eS.newInstance,update:dA},vtkPiecewiseFunction:{build:RC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:$u.newInstance,update:dA},vtkScalarBarActor:{build:Fp.newInstance,update:dA}};function xA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&lA(),Object.keys(bA).forEach((e=>{const t=bA[e];yA(e,t.build,t.update)}))}function CA(){Object.keys(TA).forEach((e=>{TA[e].forEach((t=>{QS[t]=QS[e]}))}))}xA(),CA(),nA.vtkPVLight={};var SA={build:sA,update:iA,genericUpdater:dA,oneTimeGenericUpdater:pA,setTypeMapping:yA,clearTypeMapping:lA,getSupportedTypes:function(){return Object.keys(QS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return cA();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete eA[e]})),r},updateRenderWindow:function(e,t,n){return iA("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){nA[e]={key:t,value:n}},setDefaultMapping:xA,applyDefaultAliases:CA,alwaysUpdateCamera:function(){yA("vtkCamera",$h.newInstance),CA()}};const AA={};function IA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=Wm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function wA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function PA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Et(t,n,"progressEvent"),Et(t,n,"progressDone"),t}function OA(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function RA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=AA[e];return t||(t={...IA(),...wA(),...PA(),...OA()},AA[e]=t),t}function MA(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),SA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){SA.clearOneTimeUpdaters(a())}}}function EA(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=RA(t.synchronizerContextName));const n=MA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const DA={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function VA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DA,n),vv.extend(e,t),bt(e,t,["synchronizerContext"]),EA(e,t)}var LA={newInstance:Dt(VA,"vtkSynchronizableRenderWindow"),extend:VA,getSynchronizerContext:RA,setSynchronizerContext:function(e,t){AA[e]=t},clearSynchronizerContext:function(e){if(e&&AA[e]&&delete AA[e],!e){const e=Object.keys(AA);for(let t=0;t<e.length;t++)delete AA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";const n=MA(e,RA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:wA,createArrayHandler:IA,createProgressHandler:PA,createSceneMtimeHandler:OA,vtkObjectManager:SA};const{vtkErrorMacro:BA,vtkDebugMacro:NA}=jt;let _A=0;function FA(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function kA(e){return"/"===e[0]?e.substr(1):e}const GA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=FA(kA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=FA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=kA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=FA(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=Mh(Ph(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Wm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(NA(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&BA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--_A&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};jm("html",(e=>GA));const{vtkErrorMacro:UA,vtkDebugMacro:zA}=jt;function WA(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const HA=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new $m(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Oh)return Oh.encode(e);var o=e.length,a=new $m(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new $m(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return hh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=Lh(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||UA("ERROR!!! zip not ready...");const u=WA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=Mh(Ph(new Uint8Array(e.buffer))):e.buffer=Ph(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(Nh!==e.ref.encode&&Nh&&(zA(`Swap bytes of ${e.name}`),_h(e.buffer,xs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&UA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(Mh(Ph(r))):JSON.parse(r),n()}}(i,s.compression,d);e(Mh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=Mh(Ph(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(Mh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Mh(Lh(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(Mh(s))},fetchImage(e,n){const a=WA(n);t||UA("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=zm(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Ph(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};jm("zip",(e=>HA(e)));var jA=n(892),KA=n.n(jA),$A=n(760),qA=n.n($A),XA=n(311),YA=n.n(XA),ZA=n(192),QA=n.n(ZA),JA=n(60),eI=n.n(JA),tI=n(865),nI=n.n(tI),rI=n(34),oI={};oI.styleTagTransform=nI(),oI.setAttributes=QA(),oI.insert=YA().bind(null,"head"),oI.domAPI=qA(),oI.insertStyleElement=eI(),KA()(rI.Z,oI);var aI=rI.Z&&rI.Z.locals?rI.Z.locals:void 0;let iI=!0;function sI(e){e.preventDefault(),e.stopPropagation()}function lI(e,t){iI=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=nC.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=LA.getSynchronizerContext(),a=LA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",aI.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?zh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Km("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):zh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Km("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=Wm(t.base64Str),n=Km("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function cI(e){iI=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(aI.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${aI.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){sI(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];lI(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",sI)}const uI=ny();if(uI.url||uI.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(aI.fullScreen),t.style.margin="0",t.style.padding="0"),iI=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>lI(n,uI)))}setTimeout((()=>{iI&&cI()}),100),window.OfflineLocalView={initLocalFileLoader:cI,load:lI}},793:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},490:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},22:function(e){"use strict";e.exports=function(e){return e[1]}},145:function(e,t,n){"use strict";var r=n(426),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},177:function(e,t,n){"use strict";var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){"use strict";var r=n(491);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){"use strict";var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&"constructor"===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){"use strict";var t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r="";for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join("")}function l(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){"use strict";var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.Z=u},396:function(e,t,n){var r=n(819),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},60:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},760:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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Okyf0zNKAV+YGUe/LMxVPC/HozbwH/BHy930+0N2WHIJuwwDQhXyg2Ops8qZjAj+tSHFJ9bA0aJzpndy2Fwg/9InHZKYHvf1q8uqvpcz4Mvx2M4PYl9fQNyDcnU2o3VR000P6UT2gB/bh569Y1pf8ax/WH08R8DP//rvf/+3fzGh6PsizZBByEQcQ3tSEAXA9AzLSDQlRP9JsRRFx//6j3/7r3+lXp/Cf/y/PwNfP6y/aP/IuWy8gaHlrvPW/e/TUOx/hn8p3uD975+Dph6iethPyf/3n6uM/o7/jv+O/47/jv+O/47/jv+O/47/jv+O/47/jv+O/47/jv+O/47/jv+O/4edK2laVmmyf+WLu6UjmKdvh4ggg6Ay6aYDGQRRFJGxo/97Zz6LXve2I1i99zxciqqsHE5mZbniFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8YpXvOIVr3jFK17xile84hWveMUrXvGKV7ziFa94xSte8f8f/M9//8e//sn5jKYSkUlzWkokihUYmZYYlmFEipcFVvhPmRaZ7J9//+u//imTroT/+L++AoP/5k+Ob+ye7+QncMr3m8z49+FX45/hn23yS/73z+m7+eXNDx+pQnX4GbeXtJWps7MQJen/vFmwS6MbIkKCtTzFVn+T0pZ8Rjr97gx28GhqGyaD6bkSeemnwzmLG2krvfrThWU+29GT9u7rdtr0vUSKFyNw94UhbQmu4DcNfREHb3m8om+6H3uOPHSEXhieJy7kbo7DyJLI3ptsp7x5pZxL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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
